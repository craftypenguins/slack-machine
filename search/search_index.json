{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Slack Machine","text":"<p>Slack Machine is a simple, yet powerful and extendable Slack bot framework. More than just a bot, Slack Machine is a framework that helps you develop your Slack workspace into a ChatOps powerhouse. Slack Machine is built with an intuitive plugin system that lets you build bots quickly, but also allows for easy code organization. A plugin can look as simple as this:</p> <pre><code>from machine.plugins.base import MachineBasePlugin\nfrom machine.plugins.message import Message\nfrom machine.plugins.decorators import respond_to\n\n\nclass DeploymentPlugin(MachineBasePlugin):\n\"\"\"Deployments\"\"\"\n\n    @respond_to(r\"deploy (?P&lt;application&gt;\\w+) to (?P&lt;environment&gt;\\w+)\")\n    async def deploy(self, msg: Message, application, environment):\n\"\"\"deploy &lt;application&gt; &lt;environment&gt;: deploy application to target environment\"\"\"\n        await msg.say(f\"Deploying {application} to {environment}\")\n</code></pre>"},{"location":"#breaking-changes","title":"Breaking Changes","text":"<p>Plugin initialization is now async (v0.35.0)</p> <p>The optional initialization method plugins can implement, which is run once when the plugin is loaded, should be an async method starting the upcoming v0.35.0. The reason for this is that this allows plugins to interact with Slack through the Slack Machine's plugin API - most of which methods are async.</p> <p>Simply prefix your <code>init()</code> methods with <code>async</code>.</p> <p>Dropped support for Python 3.7 (v0.34.0)</p> <p>As of v0.34.0, support for Python 3.7 has been dropped. Python 3.7 has reached end-of-life on 2023-06-27.</p> <p>AsyncIO (v0.30.0)</p> <p>As of v0.30.0 Slack Machine dropped support for the old backend based on the RTM API. As such, Slack Machine is now fully based on AsyncIO. This means plugins written before the rewrite to asyncio aren't supported anymore. See here for a migration guide to get your old plugins working with the new version of Slack Machine.</p> <p>It's really easy!</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Get started with mininal configuration</li> <li>Built on top of the Slack Events API for smoothly responding   to events in semi real-time. Uses Socket Mode so your bot doesn't   need to be exposed to the internet!</li> <li>Support for rich interactions using the Slack Web API</li> <li>High-level API for maximum convenience when building plugins</li> <li>Low-level API for maximum flexibility</li> <li>Built on top of AsyncIO to ensure good performance by handling   communication with Slack concurrently</li> </ul>"},{"location":"#plugin-api-features","title":"Plugin API features:","text":"<ul> <li>Listen and respond to any regular expression</li> <li>Respond to Slash Commands</li> <li>Capture parts of messages to use as variables in your functions</li> <li>Respond to messages in channels, groups and direct message conversations</li> <li>Respond with reactions</li> <li>Respond in threads</li> <li>Respond with ephemeral messages</li> <li>Send DMs to any user</li> <li>Support for blocks</li> <li>Support for message attachments [Legacy \ud83c\udfda]</li> <li>Listen and respond to any Slack event supported by the Events API</li> <li>Store and retrieve any kind of data in persistent storage (currently Redis, DynamoDB, SQLite, and in-memory storage   are supported)</li> <li>Schedule actions and messages</li> <li>Emit and listen for events</li> <li>Help texts for Plugins</li> </ul>"},{"location":"#coming-soon","title":"Coming Soon","text":"<ul> <li>Support for Interactive Buttons</li> <li>... and much more</li> </ul>"},{"location":"api/","title":"API Documentation","text":"<p>This is the API documentation of all the classes and functions relevant for Plugin development. The rest of the code deals with the internal workings of Slack Machine and is very much an implementation detail and subject to change. Therefore it is not documented.</p>"},{"location":"api/#plugin-classes","title":"Plugin classes","text":"<p>The following classes form the basis for Plugin development.</p>"},{"location":"api/#machine.plugins.base.MachineBasePlugin","title":"<code>machine.plugins.base.MachineBasePlugin</code>","text":"<p>Base class for all Slack Machine plugins</p> <p>The purpose of this class is two-fold:</p> <ol> <li>It acts as a marker-class so Slack Machine can recognize plugins as such</li> <li>It provides a lot of common functionality and convenience methods for plugins to    interact with channels and users</li> </ol> <p>Attributes:</p> Name Type Description <code>settings</code> <code>CaseInsensitiveDict</code> <p>Slack Machine settings object that contains all settings that were defined through <code>local_settings.py</code> Plugin developers can use any settings that are defined by the user, and ask users to add new settings specifically for their plugin.</p> Source code in <code>machine/plugins/base.py</code> <pre><code>class MachineBasePlugin:\n\"\"\"Base class for all Slack Machine plugins\n\n    The purpose of this class is two-fold:\n\n    1. It acts as a marker-class so Slack Machine can recognize plugins as such\n    2. It provides a lot of common functionality and convenience methods for plugins to\n       interact with channels and users\n\n    :var settings: Slack Machine settings object that contains all settings that\n        were defined through ``local_settings.py`` Plugin developers can use any\n        settings that are defined by the user, and ask users to add new settings\n        specifically for their plugin.\n    \"\"\"\n\n    _client: SlackClient\n    storage: PluginStorage\n    settings: CaseInsensitiveDict\n    _fq_name: str\n\n    def __init__(self, client: SlackClient, settings: CaseInsensitiveDict, storage: PluginStorage):\n        self._client = client\n        self.storage = storage\n        self.settings = settings\n        self._fq_name = f\"{self.__module__}.{self.__class__.__name__}\"\n\n    async def init(self) -&gt; None:\n\"\"\"Initialize plugin\n\n        This method can be implemented by concrete plugin classes. It will be called **once**\n        for each plugin, when that plugin is first loaded. You can refer to settings via\n        ``self.settings``, and access storage through ``self.storage``, but the Slack client has\n        not been initialized yet, so you cannot send or process messages during initialization.\n\n        :return: None\n        \"\"\"\n        return None\n\n    @property\n    def users(self) -&gt; dict[str, User]:\n\"\"\"Dictionary of all users in the Slack workspace\n\n        :return: a dictionary of all users in the Slack workspace, where the key is the user id and\n            the value is a [`User`][machine.models.user.User] object\n        \"\"\"\n        return self._client.users\n\n    @property\n    def users_by_email(self) -&gt; dict[str, User]:\n\"\"\"Dictionary of all users in the Slack workspace by email\n\n        **Note**: not every user might have an email address in their profile, so this\n        dictionary might not contain all users in the Slack workspace\n\n        :return: a dictionary of all users in the Slack workspace, where the key is the email and\n            the value is a [`User`][machine.models.user.User] object\n        \"\"\"\n        return self._client.users\n\n    @property\n    def channels(self) -&gt; dict[str, Channel]:\n\"\"\"List of all channels in the Slack workspace\n\n        This is a list of all channels in the Slack workspace that the bot is aware of. This\n        includes all public channels, all private channels the bot is a member of and all DM\n        channels the bot is a member of.\n\n        :return: a list of all channels in the Slack workspace, where each channel is a\n            :py:class:`~machine.models.channel.Channel` object\n        \"\"\"\n        return self._client.channels\n\n    @property\n    def web_client(self) -&gt; AsyncWebClient:\n\"\"\"Slack SDK web client to access the [Slack Web API][slack-web-api]\n\n        This property references an instance of [`AsyncWebClient`][async-web-client]\n\n        [slack-web-api]: https://api.slack.com/web\n        [async-web-client]: https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/async_client.html#slack_sdk.web.async_client.AsyncWebClient\n        \"\"\"  # noqa: E501\n        return self._client.web_client\n\n    def find_channel_by_name(self, channel_name: str) -&gt; Channel | None:\n\"\"\"Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs.\n\n        :param channel_name: The name of the channel to retrieve.\n        :return: The channel if found, None otherwise.\n        \"\"\"\n        if channel_name.startswith(\"#\"):\n            channel_name = channel_name[1:]\n        for c in self.channels.values():\n            if c.name_normalized and channel_name.lower() == c.name_normalized.lower():\n                return c\n        return None\n\n    def get_user_by_id(self, user_id: str) -&gt; User | None:\n\"\"\"Get a user by their ID.\n\n        :param user_id: The ID of the user to retrieve.\n        :return: The user if found, None otherwise.\n        \"\"\"\n        return self.users.get(user_id)\n\n    def get_user_by_email(self, email: str) -&gt; User | None:\n\"\"\"Get a user by their email address.\n\n        :param email: The email address of the user to retrieve.\n        :return: The user if found, None otherwise.\n        \"\"\"\n        return self._client.get_user_by_email(email)\n\n    @property\n    def bot_info(self) -&gt; dict[str, Any]:\n\"\"\"Information about the bot user in Slack\n\n        This will return a dictionary with information about the bot user in Slack that represents\n        Slack Machine\n\n        :return: Bot user\n        \"\"\"\n        return self._client.bot_info\n\n    def at(self, user: User) -&gt; str:\n\"\"\"Create a mention of the provided user\n\n        Create a mention of the provided user in the form of ``&lt;@[user_id]&gt;``. This method is\n        convenient when you want to include mentions in your message. This method does not send\n        a message, but should be used together with methods like\n        :py:meth:`~machine.plugins.base.MachineBasePlugin.say`\n\n        :param user: user your want to mention\n        :return: user mention\n        \"\"\"\n        return user.fmt_mention()\n\n    async def say(\n        self,\n        channel: Channel | str,\n        text: str | None = None,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        thread_ts: str | None = None,\n        ephemeral_user: User | str | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n\"\"\"Send a message to a channel\n\n        Send a message to a channel using the WebAPI. Allows for rich formatting using\n        `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or\n        you can use the `convenient classes`_ that the underlying slack client provides.\n        Can also reply in-thread and send ephemeral messages, visible to only one user.\n        Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral_user``\n        takes precedence over ``thread_ts``\n        Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or\n        `chat.postEphemeral`_ request.\n\n        .. _attachments: https://api.slack.com/docs/message-attachments\n        .. _blocks: https://api.slack.com/reference/block-kit/blocks\n        .. _convenient classes:\n            https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes\n\n        :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send\n            message to. Can be public or private (group) channel, or DM channel.\n        :param text: message text\n        :param attachments: optional attachments (see `attachments`_)\n        :param blocks: optional blocks (see `blocks`_)\n        :param thread_ts: optional timestamp of thread, to send a message in that thread\n        :param ephemeral_user: optional user name or id if the message needs to visible\n            to a specific user only\n        :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_\n            if `ephemeral_user` is True.\n\n        .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage\n        .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral\n        \"\"\"\n        return await self._client.send(\n            channel,\n            text=text,\n            attachments=attachments,\n            blocks=blocks,\n            thread_ts=thread_ts,\n            ephemeral_user=ephemeral_user,\n            **kwargs,\n        )\n\n    async def say_scheduled(\n        self,\n        when: datetime,\n        channel: Channel | str,\n        text: str,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        thread_ts: str | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n\"\"\"Schedule a message to a channel\n\n        This is the scheduled version of :py:meth:`~machine.plugins.base.MachineBasePlugin.say`.\n        It behaves the same, but will send the message at the scheduled time.\n\n        :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance\n        :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send\n            message to. Can be public or private (group) channel, or DM channel.\n        :param text: message text\n        :param attachments: optional attachments (see `attachments`_)\n        :param blocks: optional blocks (see `blocks`_)\n        :param thread_ts: optional timestamp of thread, to send a message in that thread\n        :return: None\n\n        .. _attachments: https://api.slack.com/docs/message-attachments\n        .. _blocks: https://api.slack.com/reference/block-kit/blocks\n        \"\"\"\n        return await self._client.send_scheduled(\n            when,\n            channel,\n            text=text,\n            attachments=attachments,\n            blocks=blocks,\n            thread_ts=thread_ts,\n            **kwargs,\n        )\n\n    async def react(self, channel: Channel | str, ts: str, emoji: str) -&gt; AsyncSlackResponse:\n\"\"\"React to a message in a channel\n\n        Add a reaction to a message in a channel. What message to react to, is determined by the\n        combination of the channel and the timestamp of the message.\n\n        :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send\n            message to. Can be public or private (group) channel, or DM channel.\n        :param ts: timestamp of the message to react to\n        :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.)\n        :return: Dictionary deserialized from `reactions.add`_ request.\n\n        .. _reactions.add: https://api.slack.com/methods/reactions.add\n        \"\"\"\n        return await self._client.react(channel, ts, emoji)\n\n    async def send_dm(\n        self,\n        user: User | str,\n        text: str | None = None,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n\"\"\"Send a Direct Message\n\n        Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows\n        for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and\n        attachments as Python dicts or you can use the `convenient classes`_ that the underlying\n        slack client provides.\n        Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request.\n\n        .. _attachments: https://api.slack.com/docs/message-attachments\n        .. _blocks: https://api.slack.com/reference/block-kit/blocks\n        .. _convenient classes:\n            https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes\n\n        :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to.\n        :param text: message text\n        :param attachments: optional attachments (see `attachments`_)\n        :param blocks: optional blocks (see `blocks`_)\n        :return: Dictionary deserialized from `chat.postMessage`_ request.\n\n        .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage\n        \"\"\"\n        return await self._client.send_dm(user, text, attachments=attachments, blocks=blocks, **kwargs)\n\n    async def send_dm_scheduled(\n        self,\n        when: datetime,\n        user: User | str,\n        text: str,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n\"\"\"Schedule a Direct Message\n\n        This is the scheduled version of\n        :py:meth:`~machine.plugins.base.MachineBasePlugin.send_dm`. It behaves the same, but\n        will send the DM at the scheduled time.\n\n        :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance\n        :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to.\n        :param text: message text\n        :param attachments: optional attachments (see `attachments`_)\n        :param blocks: optional blocks (see `blocks`_)\n        :return: None\n\n        .. _attachments: https://api.slack.com/docs/message-attachments\n        .. _blocks: https://api.slack.com/reference/block-kit/blocks\n        \"\"\"\n        return await self._client.send_dm_scheduled(\n            when, user, text=text, attachments=attachments, blocks=blocks, **kwargs\n        )\n\n    def emit(self, event: str, **kwargs: Any) -&gt; None:\n\"\"\"Emit an event\n\n        Emit an event that plugins can listen for. You can include arbitrary data as keyword\n        arguments.\n\n        :param event: name of the event\n        :param **kwargs: any data you want to emit with the event\n        :return: None\n        \"\"\"\n        ee.emit(event, self, **kwargs)\n\n    async def pin_message(self, channel: Channel | str, ts: str) -&gt; AsyncSlackResponse:\n\"\"\"Pin message\n\n        Pin a message in a channel\n\n        :param channel: channel to pin the message in\n        :param ts: timestamp of the message to pin\n        :return: response from the Slack Web API\n        \"\"\"\n        return await self._client.pin_message(channel, ts)\n\n    async def unpin_message(self, channel: Channel | str, ts: str) -&gt; AsyncSlackResponse:\n\"\"\"Unpin message\n\n        Unpin a message that was previously pinned in a channel\n\n        :param channel: channel where the message is pinned that needs to be unpinned\n        :param ts: timestamp of the message to unpin\n        :return: response from the Slack Web API\n        \"\"\"\n        return await self._client.unpin_message(channel, ts)\n\n    async def set_topic(self, channel: Channel | str, topic: str, **kwargs: Any) -&gt; AsyncSlackResponse:\n\"\"\"Set channel topic\n\n        Set or update topic for the channel\n\n        :param channel: channel where topic needs to be set or updated\n        :param topic: topic for the channel (slack does not support formatting for topics)\n        :return: response from the Slack Web API\n        \"\"\"\n        return await self._client.set_topic(channel, topic, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.users","title":"<code>users: dict[str, User]</code>  <code>property</code>","text":"<p>Dictionary of all users in the Slack workspace</p> <p>Returns:</p> Type Description <p>a dictionary of all users in the Slack workspace, where the key is the user id and the value is a <code>User</code> object</p>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.users_by_email","title":"<code>users_by_email: dict[str, User]</code>  <code>property</code>","text":"<p>Dictionary of all users in the Slack workspace by email</p> <p>Note: not every user might have an email address in their profile, so this dictionary might not contain all users in the Slack workspace</p> <p>Returns:</p> Type Description <p>a dictionary of all users in the Slack workspace, where the key is the email and the value is a <code>User</code> object</p>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.channels","title":"<code>channels: dict[str, Channel]</code>  <code>property</code>","text":"<p>List of all channels in the Slack workspace</p> <p>This is a list of all channels in the Slack workspace that the bot is aware of. This includes all public channels, all private channels the bot is a member of and all DM channels the bot is a member of.</p> <p>Returns:</p> Type Description <p>a list of all channels in the Slack workspace, where each channel is a :py:class:<code>~machine.models.channel.Channel</code> object</p>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.web_client","title":"<code>web_client: AsyncWebClient</code>  <code>property</code>","text":"<p>Slack SDK web client to access the Slack Web API</p> <p>This property references an instance of <code>AsyncWebClient</code></p>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.bot_info","title":"<code>bot_info: dict[str, Any]</code>  <code>property</code>","text":"<p>Information about the bot user in Slack</p> <p>This will return a dictionary with information about the bot user in Slack that represents Slack Machine</p> <p>Returns:</p> Type Description <p>Bot user</p>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.init","title":"<code>init() -&gt; None</code>  <code>async</code>","text":"<p>Initialize plugin</p> <p>This method can be implemented by concrete plugin classes. It will be called once for each plugin, when that plugin is first loaded. You can refer to settings via <code>self.settings</code>, and access storage through <code>self.storage</code>, but the Slack client has not been initialized yet, so you cannot send or process messages during initialization.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>machine/plugins/base.py</code> <pre><code>async def init(self) -&gt; None:\n\"\"\"Initialize plugin\n\n    This method can be implemented by concrete plugin classes. It will be called **once**\n    for each plugin, when that plugin is first loaded. You can refer to settings via\n    ``self.settings``, and access storage through ``self.storage``, but the Slack client has\n    not been initialized yet, so you cannot send or process messages during initialization.\n\n    :return: None\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.find_channel_by_name","title":"<code>find_channel_by_name(channel_name: str) -&gt; Channel | None</code>","text":"<p>Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs.</p> <p>Parameters:</p> Name Type Description Default <code>channel_name</code> <code>str</code> <p>The name of the channel to retrieve.</p> required <p>Returns:</p> Type Description <code>Channel | None</code> <p>The channel if found, None otherwise.</p> Source code in <code>machine/plugins/base.py</code> <pre><code>def find_channel_by_name(self, channel_name: str) -&gt; Channel | None:\n\"\"\"Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs.\n\n    :param channel_name: The name of the channel to retrieve.\n    :return: The channel if found, None otherwise.\n    \"\"\"\n    if channel_name.startswith(\"#\"):\n        channel_name = channel_name[1:]\n    for c in self.channels.values():\n        if c.name_normalized and channel_name.lower() == c.name_normalized.lower():\n            return c\n    return None\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.get_user_by_id","title":"<code>get_user_by_id(user_id: str) -&gt; User | None</code>","text":"<p>Get a user by their ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>The ID of the user to retrieve.</p> required <p>Returns:</p> Type Description <code>User | None</code> <p>The user if found, None otherwise.</p> Source code in <code>machine/plugins/base.py</code> <pre><code>def get_user_by_id(self, user_id: str) -&gt; User | None:\n\"\"\"Get a user by their ID.\n\n    :param user_id: The ID of the user to retrieve.\n    :return: The user if found, None otherwise.\n    \"\"\"\n    return self.users.get(user_id)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.get_user_by_email","title":"<code>get_user_by_email(email: str) -&gt; User | None</code>","text":"<p>Get a user by their email address.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>The email address of the user to retrieve.</p> required <p>Returns:</p> Type Description <code>User | None</code> <p>The user if found, None otherwise.</p> Source code in <code>machine/plugins/base.py</code> <pre><code>def get_user_by_email(self, email: str) -&gt; User | None:\n\"\"\"Get a user by their email address.\n\n    :param email: The email address of the user to retrieve.\n    :return: The user if found, None otherwise.\n    \"\"\"\n    return self._client.get_user_by_email(email)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.at","title":"<code>at(user: User) -&gt; str</code>","text":"<p>Create a mention of the provided user</p> <p>Create a mention of the provided user in the form of <code>&lt;@[user_id]&gt;</code>. This method is convenient when you want to include mentions in your message. This method does not send a message, but should be used together with methods like :py:meth:<code>~machine.plugins.base.MachineBasePlugin.say</code></p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>user your want to mention</p> required <p>Returns:</p> Type Description <code>str</code> <p>user mention</p> Source code in <code>machine/plugins/base.py</code> <pre><code>def at(self, user: User) -&gt; str:\n\"\"\"Create a mention of the provided user\n\n    Create a mention of the provided user in the form of ``&lt;@[user_id]&gt;``. This method is\n    convenient when you want to include mentions in your message. This method does not send\n    a message, but should be used together with methods like\n    :py:meth:`~machine.plugins.base.MachineBasePlugin.say`\n\n    :param user: user your want to mention\n    :return: user mention\n    \"\"\"\n    return user.fmt_mention()\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.say","title":"<code>say(channel: Channel | str, text: str | None = None, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, thread_ts: str | None = None, ephemeral_user: User | str | None = None, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Send a message to a channel</p> <p>Send a message to a channel using the WebAPI. Allows for rich formatting using <code>blocks</code> and/or <code>attachments</code>. You can provide blocks and attachments as Python dicts or you can use the <code>convenient classes</code> that the underlying slack client provides. Can also reply in-thread and send ephemeral messages, visible to only one user. Ephemeral messages and threaded messages are mutually exclusive, and <code>ephemeral_user</code> takes precedence over <code>thread_ts</code> Any extra kwargs you provide, will be passed on directly to the <code>chat.postMessage</code> or <code>chat.postEphemeral</code>_ request.</p> <p>.. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes:     https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel | str</code> <p>:py:class:<code>~machine.models.channel.Channel</code> object or id of channel to send message to. Can be public or private (group) channel, or DM channel.</p> required <code>text</code> <code>str | None</code> <p>message text</p> <code>None</code> <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see <code>attachments</code>_)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see <code>blocks</code>_)</p> <code>None</code> <code>thread_ts</code> <code>str | None</code> <p>optional timestamp of thread, to send a message in that thread</p> <code>None</code> <code>ephemeral_user</code> <code>User | str | None</code> <p>optional user name or id if the message needs to visible to a specific user only</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from <code>chat.postMessage</code> request, or <code>chat.postEphemeral</code> if <code>ephemeral_user</code> is True.  .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral</p> Source code in <code>machine/plugins/base.py</code> <pre><code>async def say(\n    self,\n    channel: Channel | str,\n    text: str | None = None,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    thread_ts: str | None = None,\n    ephemeral_user: User | str | None = None,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n\"\"\"Send a message to a channel\n\n    Send a message to a channel using the WebAPI. Allows for rich formatting using\n    `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or\n    you can use the `convenient classes`_ that the underlying slack client provides.\n    Can also reply in-thread and send ephemeral messages, visible to only one user.\n    Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral_user``\n    takes precedence over ``thread_ts``\n    Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or\n    `chat.postEphemeral`_ request.\n\n    .. _attachments: https://api.slack.com/docs/message-attachments\n    .. _blocks: https://api.slack.com/reference/block-kit/blocks\n    .. _convenient classes:\n        https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes\n\n    :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send\n        message to. Can be public or private (group) channel, or DM channel.\n    :param text: message text\n    :param attachments: optional attachments (see `attachments`_)\n    :param blocks: optional blocks (see `blocks`_)\n    :param thread_ts: optional timestamp of thread, to send a message in that thread\n    :param ephemeral_user: optional user name or id if the message needs to visible\n        to a specific user only\n    :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_\n        if `ephemeral_user` is True.\n\n    .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage\n    .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral\n    \"\"\"\n    return await self._client.send(\n        channel,\n        text=text,\n        attachments=attachments,\n        blocks=blocks,\n        thread_ts=thread_ts,\n        ephemeral_user=ephemeral_user,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.say_scheduled","title":"<code>say_scheduled(when: datetime, channel: Channel | str, text: str, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, thread_ts: str | None = None, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Schedule a message to a channel</p> <p>This is the scheduled version of :py:meth:<code>~machine.plugins.base.MachineBasePlugin.say</code>. It behaves the same, but will send the message at the scheduled time.</p> <p>Parameters:</p> Name Type Description Default <code>when</code> <code>datetime</code> <p>when you want the message to be sent, as :py:class:<code>datetime.datetime</code> instance</p> required <code>channel</code> <code>Channel | str</code> <p>:py:class:<code>~machine.models.channel.Channel</code> object or id of channel to send message to. Can be public or private (group) channel, or DM channel.</p> required <code>text</code> <code>str</code> <p>message text</p> required <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see <code>attachments</code>_)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see <code>blocks</code>_)</p> <code>None</code> <code>thread_ts</code> <code>str | None</code> <p>optional timestamp of thread, to send a message in that thread</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>None  .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks</p> Source code in <code>machine/plugins/base.py</code> <pre><code>async def say_scheduled(\n    self,\n    when: datetime,\n    channel: Channel | str,\n    text: str,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    thread_ts: str | None = None,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n\"\"\"Schedule a message to a channel\n\n    This is the scheduled version of :py:meth:`~machine.plugins.base.MachineBasePlugin.say`.\n    It behaves the same, but will send the message at the scheduled time.\n\n    :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance\n    :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send\n        message to. Can be public or private (group) channel, or DM channel.\n    :param text: message text\n    :param attachments: optional attachments (see `attachments`_)\n    :param blocks: optional blocks (see `blocks`_)\n    :param thread_ts: optional timestamp of thread, to send a message in that thread\n    :return: None\n\n    .. _attachments: https://api.slack.com/docs/message-attachments\n    .. _blocks: https://api.slack.com/reference/block-kit/blocks\n    \"\"\"\n    return await self._client.send_scheduled(\n        when,\n        channel,\n        text=text,\n        attachments=attachments,\n        blocks=blocks,\n        thread_ts=thread_ts,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.react","title":"<code>react(channel: Channel | str, ts: str, emoji: str) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>React to a message in a channel</p> <p>Add a reaction to a message in a channel. What message to react to, is determined by the combination of the channel and the timestamp of the message.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel | str</code> <p>:py:class:<code>~machine.models.channel.Channel</code> object or id of channel to send message to. Can be public or private (group) channel, or DM channel.</p> required <code>ts</code> <code>str</code> <p>timestamp of the message to react to</p> required <code>emoji</code> <code>str</code> <p>what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.)</p> required <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from <code>reactions.add</code>_ request.  .. _reactions.add: https://api.slack.com/methods/reactions.add</p> Source code in <code>machine/plugins/base.py</code> <pre><code>async def react(self, channel: Channel | str, ts: str, emoji: str) -&gt; AsyncSlackResponse:\n\"\"\"React to a message in a channel\n\n    Add a reaction to a message in a channel. What message to react to, is determined by the\n    combination of the channel and the timestamp of the message.\n\n    :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send\n        message to. Can be public or private (group) channel, or DM channel.\n    :param ts: timestamp of the message to react to\n    :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.)\n    :return: Dictionary deserialized from `reactions.add`_ request.\n\n    .. _reactions.add: https://api.slack.com/methods/reactions.add\n    \"\"\"\n    return await self._client.react(channel, ts, emoji)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.send_dm","title":"<code>send_dm(user: User | str, text: str | None = None, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Send a Direct Message</p> <p>Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows for rich formatting using <code>blocks</code> and/or <code>attachments</code>. You can provide blocks and attachments as Python dicts or you can use the <code>convenient classes</code> that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the <code>chat.postMessage</code> request.</p> <p>.. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes:     https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User | str</code> <p>:py:class:<code>~machine.models.user.User</code> object or id of user to send DM to.</p> required <code>text</code> <code>str | None</code> <p>message text</p> <code>None</code> <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see <code>attachments</code>_)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see <code>blocks</code>_)</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from <code>chat.postMessage</code>_ request.  .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage</p> Source code in <code>machine/plugins/base.py</code> <pre><code>async def send_dm(\n    self,\n    user: User | str,\n    text: str | None = None,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n\"\"\"Send a Direct Message\n\n    Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows\n    for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and\n    attachments as Python dicts or you can use the `convenient classes`_ that the underlying\n    slack client provides.\n    Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request.\n\n    .. _attachments: https://api.slack.com/docs/message-attachments\n    .. _blocks: https://api.slack.com/reference/block-kit/blocks\n    .. _convenient classes:\n        https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes\n\n    :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to.\n    :param text: message text\n    :param attachments: optional attachments (see `attachments`_)\n    :param blocks: optional blocks (see `blocks`_)\n    :return: Dictionary deserialized from `chat.postMessage`_ request.\n\n    .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage\n    \"\"\"\n    return await self._client.send_dm(user, text, attachments=attachments, blocks=blocks, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.send_dm_scheduled","title":"<code>send_dm_scheduled(when: datetime, user: User | str, text: str, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Schedule a Direct Message</p> <p>This is the scheduled version of :py:meth:<code>~machine.plugins.base.MachineBasePlugin.send_dm</code>. It behaves the same, but will send the DM at the scheduled time.</p> <p>Parameters:</p> Name Type Description Default <code>when</code> <code>datetime</code> <p>when you want the message to be sent, as :py:class:<code>datetime.datetime</code> instance</p> required <code>user</code> <code>User | str</code> <p>:py:class:<code>~machine.models.user.User</code> object or id of user to send DM to.</p> required <code>text</code> <code>str</code> <p>message text</p> required <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see <code>attachments</code>_)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see <code>blocks</code>_)</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>None  .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks</p> Source code in <code>machine/plugins/base.py</code> <pre><code>async def send_dm_scheduled(\n    self,\n    when: datetime,\n    user: User | str,\n    text: str,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n\"\"\"Schedule a Direct Message\n\n    This is the scheduled version of\n    :py:meth:`~machine.plugins.base.MachineBasePlugin.send_dm`. It behaves the same, but\n    will send the DM at the scheduled time.\n\n    :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance\n    :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to.\n    :param text: message text\n    :param attachments: optional attachments (see `attachments`_)\n    :param blocks: optional blocks (see `blocks`_)\n    :return: None\n\n    .. _attachments: https://api.slack.com/docs/message-attachments\n    .. _blocks: https://api.slack.com/reference/block-kit/blocks\n    \"\"\"\n    return await self._client.send_dm_scheduled(\n        when, user, text=text, attachments=attachments, blocks=blocks, **kwargs\n    )\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.emit","title":"<code>emit(event: str, **kwargs: Any) -&gt; None</code>","text":"<p>Emit an event</p> <p>Emit an event that plugins can listen for. You can include arbitrary data as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>str</code> <p>name of the event</p> required <code>**kwargs</code> <code>Any</code> <p>any data you want to emit with the event</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>machine/plugins/base.py</code> <pre><code>def emit(self, event: str, **kwargs: Any) -&gt; None:\n\"\"\"Emit an event\n\n    Emit an event that plugins can listen for. You can include arbitrary data as keyword\n    arguments.\n\n    :param event: name of the event\n    :param **kwargs: any data you want to emit with the event\n    :return: None\n    \"\"\"\n    ee.emit(event, self, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.pin_message","title":"<code>pin_message(channel: Channel | str, ts: str) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Pin message</p> <p>Pin a message in a channel</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel | str</code> <p>channel to pin the message in</p> required <code>ts</code> <code>str</code> <p>timestamp of the message to pin</p> required <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>response from the Slack Web API</p> Source code in <code>machine/plugins/base.py</code> <pre><code>async def pin_message(self, channel: Channel | str, ts: str) -&gt; AsyncSlackResponse:\n\"\"\"Pin message\n\n    Pin a message in a channel\n\n    :param channel: channel to pin the message in\n    :param ts: timestamp of the message to pin\n    :return: response from the Slack Web API\n    \"\"\"\n    return await self._client.pin_message(channel, ts)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.unpin_message","title":"<code>unpin_message(channel: Channel | str, ts: str) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Unpin message</p> <p>Unpin a message that was previously pinned in a channel</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel | str</code> <p>channel where the message is pinned that needs to be unpinned</p> required <code>ts</code> <code>str</code> <p>timestamp of the message to unpin</p> required <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>response from the Slack Web API</p> Source code in <code>machine/plugins/base.py</code> <pre><code>async def unpin_message(self, channel: Channel | str, ts: str) -&gt; AsyncSlackResponse:\n\"\"\"Unpin message\n\n    Unpin a message that was previously pinned in a channel\n\n    :param channel: channel where the message is pinned that needs to be unpinned\n    :param ts: timestamp of the message to unpin\n    :return: response from the Slack Web API\n    \"\"\"\n    return await self._client.unpin_message(channel, ts)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.set_topic","title":"<code>set_topic(channel: Channel | str, topic: str, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Set channel topic</p> <p>Set or update topic for the channel</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel | str</code> <p>channel where topic needs to be set or updated</p> required <code>topic</code> <code>str</code> <p>topic for the channel (slack does not support formatting for topics)</p> required <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>response from the Slack Web API</p> Source code in <code>machine/plugins/base.py</code> <pre><code>async def set_topic(self, channel: Channel | str, topic: str, **kwargs: Any) -&gt; AsyncSlackResponse:\n\"\"\"Set channel topic\n\n    Set or update topic for the channel\n\n    :param channel: channel where topic needs to be set or updated\n    :param topic: topic for the channel (slack does not support formatting for topics)\n    :return: response from the Slack Web API\n    \"\"\"\n    return await self._client.set_topic(channel, topic, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.message.Message","title":"<code>machine.plugins.message.Message</code>","text":"<p>A message that was received by the bot</p> <p>This class represents a message that was received by the bot and passed to one or more plugins. It contains the message (text) itself, and metadata about the message, such as the sender of the message, the channel the message was sent to.</p> <p>The <code>Message</code> class also contains convenience methods for replying to the message in the right channel, replying to the sender, etc.</p> Source code in <code>machine/plugins/message.py</code> <pre><code>class Message:\n\"\"\"A message that was received by the bot\n\n    This class represents a message that was received by the bot and passed to one or more\n    plugins. It contains the message (text) itself, and metadata about the message, such as the\n    sender of the message, the channel the message was sent to.\n\n    The ``Message`` class also contains convenience methods for replying to the message in the\n    right channel, replying to the sender, etc.\n    \"\"\"\n\n    # TODO: create proper class for msg_event\n    def __init__(self, client: SlackClient, msg_event: dict[str, Any]):\n        self._client = client\n        self._msg_event = msg_event\n\n    @property\n    def sender(self) -&gt; User:\n\"\"\"The sender of the message\n\n        :return: the User the message was sent by\n        \"\"\"\n        return self._client.users[self._msg_event[\"user\"]]\n\n    @property\n    def channel(self) -&gt; Channel:\n\"\"\"The channel the message was sent to\n\n        :return: the Channel the message was sent to\n        \"\"\"\n        return self._client.channels[self._msg_event[\"channel\"]]\n\n    @property\n    def is_dm(self) -&gt; bool:\n        channel_id = self._msg_event[\"channel\"]\n        return not (channel_id.startswith(\"C\") or channel_id.startswith(\"G\"))\n\n    @property\n    def text(self) -&gt; str:\n\"\"\"The body of the actual message\n\n        :return: the body (text) of the actual message\n        \"\"\"\n        return self._msg_event[\"text\"]\n\n    @property\n    def at_sender(self) -&gt; str:\n\"\"\"The sender of the message formatted as mention\n\n        :return: a string representation of the sender of the message, formatted as `mention`_,\n            to be used in messages\n\n        .. _mention: https://api.slack.com/docs/message-formatting#linking_to_channels_and_users\n        \"\"\"\n        return self.sender.fmt_mention()\n\n    async def say(\n        self,\n        text: str | None = None,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        thread_ts: str | None = None,\n        ephemeral: bool = False,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n\"\"\"Send a new message to the channel the original message was received in\n\n        Send a new message to the channel the original message was received in, using the WebAPI.\n        Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks\n        and attachments as Python dicts or you can use the `convenient classes`_ that the\n        underlying slack client provides.\n        Can also reply to a thread and send an ephemeral message only visible to the sender of the\n        original message. Ephemeral messages and threaded messages are mutually exclusive, and\n        ``ephemeral`` takes precedence over ``thread_ts``\n        Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or\n        `chat.postEphemeral`_ request.\n\n        .. _attachments: https://api.slack.com/docs/message-attachments\n        .. _blocks: https://api.slack.com/reference/block-kit/blocks\n        .. _convenient classes:\n            https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes\n\n        :param text: message text\n        :param attachments: optional attachments (see `attachments`_)\n        :param blocks: optional blocks (see `blocks`_)\n        :param thread_ts: optional timestamp of thread, to send a message in that thread\n        :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only\n            visible to the sender of the original message\n        :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_\n            if `ephemeral` is True.\n\n        .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage\n        .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral\n        \"\"\"\n        if ephemeral:\n            ephemeral_user = self.sender.id\n        else:\n            ephemeral_user = None\n\n        return await self._client.send(\n            self.channel.id,\n            text=text,\n            attachments=attachments,\n            blocks=blocks,\n            thread_ts=thread_ts,\n            ephemeral_user=ephemeral_user,\n            **kwargs,\n        )\n\n    async def say_scheduled(\n        self,\n        when: datetime,\n        text: str,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        thread_ts: str | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n\"\"\"Schedule a message\n\n        This is the scheduled version of :py:meth:`~machine.plugins.base.Message.say`.\n        It behaves the same, but will send the message at the scheduled time.\n\n        :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance\n        :param text: message text\n        :param attachments: optional attachments (see `attachments`_)\n        :param blocks: optional blocks (see `blocks`_)\n        :param thread_ts: optional timestamp of thread, to send a message in that thread\n        :return: None\n\n        .. _attachments: https://api.slack.com/docs/message-attachments\n        .. _blocks: https://api.slack.com/reference/block-kit/blocks\n        \"\"\"\n        return await self._client.send_scheduled(\n            when,\n            self.channel.id,\n            text=text,\n            attachments=attachments,\n            blocks=blocks,\n            thread_ts=thread_ts,\n            **kwargs,\n        )\n\n    async def reply(\n        self,\n        text: str | None = None,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        in_thread: bool = False,\n        ephemeral: bool = False,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n\"\"\"Reply to the sender of the original message\n\n        Reply to the sender of the original message with a new message, mentioning that user. Rich\n        formatting using `blocks`_ and/or `attachments`_ is possible. You can provide blocks\n        and attachments as Python dicts or you can use the `convenient classes`_ that the\n        underlying slack client provides.\n        Can also reply to a thread and send an ephemeral message only visible to the sender of the\n        original message. In the case of in-thread response, the sender of the original message\n        will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive,\n        and ``ephemeral`` takes precedence over ``in_thread``\n        Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or\n        `chat.postEphemeral`_ request.\n\n        .. _attachments: https://api.slack.com/docs/message-attachments\n        .. _blocks: https://api.slack.com/reference/block-kit/blocks\n        .. _convenient classes:\n            https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes\n\n        :param text: message text\n        :param attachments: optional attachments (see `attachments`_)\n        :param blocks: optional blocks (see `blocks`_)\n        :param in_thread: ``True/False`` wether to reply to the original message in-thread\n        :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only\n            visible to the sender of the original message\n        :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_\n            if `ephemeral` is True.\n\n        .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage\n        .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral\n        \"\"\"\n        if in_thread and not ephemeral:\n            return await self.say(text, attachments=attachments, blocks=blocks, thread_ts=self.ts, **kwargs)\n        else:\n            text = self._create_reply(text)\n            return await self.say(text, attachments=attachments, blocks=blocks, ephemeral=ephemeral, **kwargs)\n\n    async def reply_scheduled(\n        self,\n        when: datetime,\n        text: str,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        in_thread: bool = False,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n\"\"\"Schedule a reply and send it\n\n        This is the scheduled version of :py:meth:`~machine.plugins.base.Message.reply`.\n        It behaves the same, but will send the reply at the scheduled time.\n\n        :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance\n        :param text: message text\n        :param attachments: optional attachments (see `attachments`_)\n        :param blocks: optional blocks (see `blocks`_)\n        :param in_thread: ``True/False`` wether to reply to the original message in-thread\n        :return: None\n\n        .. _attachments: https://api.slack.com/docs/message-attachments\n        .. _blocks: https://api.slack.com/reference/block-kit/blocks\n        \"\"\"\n        if in_thread:\n            return await self.say_scheduled(\n                when, text, attachments=attachments, blocks=blocks, thread_ts=self.ts, **kwargs\n            )\n        else:\n            text = cast(str, self._create_reply(text))\n            return await self.say_scheduled(when, text, attachments=attachments, blocks=blocks, **kwargs)\n\n    async def reply_dm(\n        self,\n        text: str | None = None,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n\"\"\"Reply to the sender of the original message with a DM\n\n        Reply in a Direct Message to the sender of the original message by opening a DM channel and\n        sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_.\n        You can provide blocks and attachments as Python dicts or you can use the\n        `convenient classes`_ that the underlying slack client provides.\n        Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request.\n\n        .. _attachments: https://api.slack.com/docs/message-attachments\n        .. _blocks: https://api.slack.com/reference/block-kit/blocks\n        .. _convenient classes:\n            https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes\n\n        :param text: message text\n        :param attachments: optional attachments (see `attachments`_)\n        :param blocks: optional blocks (see `blocks`_)\n        :return: Dictionary deserialized from `chat.postMessage`_ request.\n\n        .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage\n        \"\"\"\n        return await self._client.send_dm(self.sender.id, text, attachments=attachments, blocks=blocks, **kwargs)\n\n    async def reply_dm_scheduled(\n        self,\n        when: datetime,\n        text: str,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n\"\"\"Schedule a DM reply and send it\n\n        This is the scheduled version of :py:meth:`~machine.plugins.base.Message.reply_dm`.\n        It behaves the same, but will send the DM at the scheduled time.\n\n        :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance\n        :param text: message text\n        :param attachments: optional attachments (see `attachments`_)\n        :param blocks: optional blocks (see `blocks`_)\n        :return: None\n\n        .. _attachments: https://api.slack.com/docs/message-attachments\n        .. _blocks: https://api.slack.com/reference/block-kit/blocks\n        \"\"\"\n        return await self._client.send_dm_scheduled(\n            when, self.sender.id, text=text, attachments=attachments, blocks=blocks, **kwargs\n        )\n\n    async def react(self, emoji: str) -&gt; AsyncSlackResponse:\n\"\"\"React to the original message\n\n        Add a reaction to the original message\n\n        :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.)\n        :return: Dictionary deserialized from `reactions.add`_ request.\n\n        .. _reactions.add: https://api.slack.com/methods/reactions.add\n        \"\"\"\n        return await self._client.react(self.channel.id, self._msg_event[\"ts\"], emoji)\n\n    def _create_reply(self, text: str | None) -&gt; str | None:\n        if not self.is_dm and text is not None:\n            return f\"{self.at_sender}: {text}\"\n        else:\n            return text\n\n    @property\n    def ts(self) -&gt; str:\n\"\"\"The timestamp of the message\n\n        :return: the timestamp of the message\n        \"\"\"\n        return self._msg_event[\"ts\"]\n\n    @property\n    def in_thread(self) -&gt; bool:\n\"\"\"Is message in a thread\n\n        :return: bool\n        \"\"\"\n        return \"thread_ts\" in self._msg_event\n\n    async def pin_message(self) -&gt; AsyncSlackResponse:\n\"\"\"Pin message\n\n        Pin the current message in the channel it was posted in\n        \"\"\"\n        return await self._client.pin_message(self.channel, self.ts)\n\n    def __str__(self) -&gt; str:\n        if self.channel.is_im:\n            message = f\"Message '{self.text}', sent by user @{self.sender.profile.real_name} in DM\"\n        else:\n            message = (\n                f\"Message '{self.text}', sent by user @{self.sender.profile.real_name} in channel #{self.channel.name}\"\n            )\n        return message\n\n    def __repr__(self) -&gt; str:\n        return f\"Message(text={self.text!r}, sender={self.sender.profile.real_name!r}, channel={self.channel.name!r})\"\n</code></pre>"},{"location":"api/#machine.plugins.message.Message.sender","title":"<code>sender: User</code>  <code>property</code>","text":"<p>The sender of the message</p> <p>Returns:</p> Type Description <p>the User the message was sent by</p>"},{"location":"api/#machine.plugins.message.Message.channel","title":"<code>channel: Channel</code>  <code>property</code>","text":"<p>The channel the message was sent to</p> <p>Returns:</p> Type Description <p>the Channel the message was sent to</p>"},{"location":"api/#machine.plugins.message.Message.text","title":"<code>text: str</code>  <code>property</code>","text":"<p>The body of the actual message</p> <p>Returns:</p> Type Description <p>the body (text) of the actual message</p>"},{"location":"api/#machine.plugins.message.Message.at_sender","title":"<code>at_sender: str</code>  <code>property</code>","text":"<p>The sender of the message formatted as mention</p> <p>Returns:</p> Type Description <p>a string representation of the sender of the message, formatted as <code>mention</code>_, to be used in messages  .. _mention: https://api.slack.com/docs/message-formatting#linking_to_channels_and_users</p>"},{"location":"api/#machine.plugins.message.Message.ts","title":"<code>ts: str</code>  <code>property</code>","text":"<p>The timestamp of the message</p> <p>Returns:</p> Type Description <p>the timestamp of the message</p>"},{"location":"api/#machine.plugins.message.Message.in_thread","title":"<code>in_thread: bool</code>  <code>property</code>","text":"<p>Is message in a thread</p> <p>Returns:</p> Type Description <p>bool</p>"},{"location":"api/#machine.plugins.message.Message.say","title":"<code>say(text: str | None = None, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, thread_ts: str | None = None, ephemeral: bool = False, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Send a new message to the channel the original message was received in</p> <p>Send a new message to the channel the original message was received in, using the WebAPI. Allows for rich formatting using <code>blocks</code> and/or <code>attachments</code>. You can provide blocks and attachments as Python dicts or you can use the <code>convenient classes</code> that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. Ephemeral messages and threaded messages are mutually exclusive, and <code>ephemeral</code> takes precedence over <code>thread_ts</code> Any extra kwargs you provide, will be passed on directly to the <code>chat.postMessage</code> or <code>chat.postEphemeral</code>_ request.</p> <p>.. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes:     https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>message text</p> <code>None</code> <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see <code>attachments</code>_)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see <code>blocks</code>_)</p> <code>None</code> <code>thread_ts</code> <code>str | None</code> <p>optional timestamp of thread, to send a message in that thread</p> <code>None</code> <code>ephemeral</code> <code>bool</code> <p><code>True/False</code> wether to send the message as an ephemeral message, only visible to the sender of the original message</p> <code>False</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from <code>chat.postMessage</code> request, or <code>chat.postEphemeral</code> if <code>ephemeral</code> is True.  .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral</p> Source code in <code>machine/plugins/message.py</code> <pre><code>async def say(\n    self,\n    text: str | None = None,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    thread_ts: str | None = None,\n    ephemeral: bool = False,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n\"\"\"Send a new message to the channel the original message was received in\n\n    Send a new message to the channel the original message was received in, using the WebAPI.\n    Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks\n    and attachments as Python dicts or you can use the `convenient classes`_ that the\n    underlying slack client provides.\n    Can also reply to a thread and send an ephemeral message only visible to the sender of the\n    original message. Ephemeral messages and threaded messages are mutually exclusive, and\n    ``ephemeral`` takes precedence over ``thread_ts``\n    Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or\n    `chat.postEphemeral`_ request.\n\n    .. _attachments: https://api.slack.com/docs/message-attachments\n    .. _blocks: https://api.slack.com/reference/block-kit/blocks\n    .. _convenient classes:\n        https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes\n\n    :param text: message text\n    :param attachments: optional attachments (see `attachments`_)\n    :param blocks: optional blocks (see `blocks`_)\n    :param thread_ts: optional timestamp of thread, to send a message in that thread\n    :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only\n        visible to the sender of the original message\n    :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_\n        if `ephemeral` is True.\n\n    .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage\n    .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral\n    \"\"\"\n    if ephemeral:\n        ephemeral_user = self.sender.id\n    else:\n        ephemeral_user = None\n\n    return await self._client.send(\n        self.channel.id,\n        text=text,\n        attachments=attachments,\n        blocks=blocks,\n        thread_ts=thread_ts,\n        ephemeral_user=ephemeral_user,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#machine.plugins.message.Message.say_scheduled","title":"<code>say_scheduled(when: datetime, text: str, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, thread_ts: str | None = None, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Schedule a message</p> <p>This is the scheduled version of :py:meth:<code>~machine.plugins.base.Message.say</code>. It behaves the same, but will send the message at the scheduled time.</p> <p>Parameters:</p> Name Type Description Default <code>when</code> <code>datetime</code> <p>when you want the message to be sent, as :py:class:<code>datetime.datetime</code> instance</p> required <code>text</code> <code>str</code> <p>message text</p> required <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see <code>attachments</code>_)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see <code>blocks</code>_)</p> <code>None</code> <code>thread_ts</code> <code>str | None</code> <p>optional timestamp of thread, to send a message in that thread</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>None  .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks</p> Source code in <code>machine/plugins/message.py</code> <pre><code>async def say_scheduled(\n    self,\n    when: datetime,\n    text: str,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    thread_ts: str | None = None,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n\"\"\"Schedule a message\n\n    This is the scheduled version of :py:meth:`~machine.plugins.base.Message.say`.\n    It behaves the same, but will send the message at the scheduled time.\n\n    :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance\n    :param text: message text\n    :param attachments: optional attachments (see `attachments`_)\n    :param blocks: optional blocks (see `blocks`_)\n    :param thread_ts: optional timestamp of thread, to send a message in that thread\n    :return: None\n\n    .. _attachments: https://api.slack.com/docs/message-attachments\n    .. _blocks: https://api.slack.com/reference/block-kit/blocks\n    \"\"\"\n    return await self._client.send_scheduled(\n        when,\n        self.channel.id,\n        text=text,\n        attachments=attachments,\n        blocks=blocks,\n        thread_ts=thread_ts,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#machine.plugins.message.Message.reply","title":"<code>reply(text: str | None = None, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, in_thread: bool = False, ephemeral: bool = False, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Reply to the sender of the original message</p> <p>Reply to the sender of the original message with a new message, mentioning that user. Rich formatting using <code>blocks</code> and/or <code>attachments</code> is possible. You can provide blocks and attachments as Python dicts or you can use the <code>convenient classes</code> that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. In the case of in-thread response, the sender of the original message will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive, and <code>ephemeral</code> takes precedence over <code>in_thread</code> Any extra kwargs you provide, will be passed on directly to the <code>chat.postMessage</code> or <code>chat.postEphemeral</code>_ request.</p> <p>.. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes:     https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>message text</p> <code>None</code> <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see <code>attachments</code>_)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see <code>blocks</code>_)</p> <code>None</code> <code>in_thread</code> <code>bool</code> <p><code>True/False</code> wether to reply to the original message in-thread</p> <code>False</code> <code>ephemeral</code> <code>bool</code> <p><code>True/False</code> wether to send the message as an ephemeral message, only visible to the sender of the original message</p> <code>False</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from <code>chat.postMessage</code> request, or <code>chat.postEphemeral</code> if <code>ephemeral</code> is True.  .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral</p> Source code in <code>machine/plugins/message.py</code> <pre><code>async def reply(\n    self,\n    text: str | None = None,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    in_thread: bool = False,\n    ephemeral: bool = False,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n\"\"\"Reply to the sender of the original message\n\n    Reply to the sender of the original message with a new message, mentioning that user. Rich\n    formatting using `blocks`_ and/or `attachments`_ is possible. You can provide blocks\n    and attachments as Python dicts or you can use the `convenient classes`_ that the\n    underlying slack client provides.\n    Can also reply to a thread and send an ephemeral message only visible to the sender of the\n    original message. In the case of in-thread response, the sender of the original message\n    will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive,\n    and ``ephemeral`` takes precedence over ``in_thread``\n    Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or\n    `chat.postEphemeral`_ request.\n\n    .. _attachments: https://api.slack.com/docs/message-attachments\n    .. _blocks: https://api.slack.com/reference/block-kit/blocks\n    .. _convenient classes:\n        https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes\n\n    :param text: message text\n    :param attachments: optional attachments (see `attachments`_)\n    :param blocks: optional blocks (see `blocks`_)\n    :param in_thread: ``True/False`` wether to reply to the original message in-thread\n    :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only\n        visible to the sender of the original message\n    :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_\n        if `ephemeral` is True.\n\n    .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage\n    .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral\n    \"\"\"\n    if in_thread and not ephemeral:\n        return await self.say(text, attachments=attachments, blocks=blocks, thread_ts=self.ts, **kwargs)\n    else:\n        text = self._create_reply(text)\n        return await self.say(text, attachments=attachments, blocks=blocks, ephemeral=ephemeral, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.message.Message.reply_scheduled","title":"<code>reply_scheduled(when: datetime, text: str, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, in_thread: bool = False, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Schedule a reply and send it</p> <p>This is the scheduled version of :py:meth:<code>~machine.plugins.base.Message.reply</code>. It behaves the same, but will send the reply at the scheduled time.</p> <p>Parameters:</p> Name Type Description Default <code>when</code> <code>datetime</code> <p>when you want the message to be sent, as :py:class:<code>datetime.datetime</code> instance</p> required <code>text</code> <code>str</code> <p>message text</p> required <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see <code>attachments</code>_)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see <code>blocks</code>_)</p> <code>None</code> <code>in_thread</code> <code>bool</code> <p><code>True/False</code> wether to reply to the original message in-thread</p> <code>False</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>None  .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks</p> Source code in <code>machine/plugins/message.py</code> <pre><code>async def reply_scheduled(\n    self,\n    when: datetime,\n    text: str,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    in_thread: bool = False,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n\"\"\"Schedule a reply and send it\n\n    This is the scheduled version of :py:meth:`~machine.plugins.base.Message.reply`.\n    It behaves the same, but will send the reply at the scheduled time.\n\n    :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance\n    :param text: message text\n    :param attachments: optional attachments (see `attachments`_)\n    :param blocks: optional blocks (see `blocks`_)\n    :param in_thread: ``True/False`` wether to reply to the original message in-thread\n    :return: None\n\n    .. _attachments: https://api.slack.com/docs/message-attachments\n    .. _blocks: https://api.slack.com/reference/block-kit/blocks\n    \"\"\"\n    if in_thread:\n        return await self.say_scheduled(\n            when, text, attachments=attachments, blocks=blocks, thread_ts=self.ts, **kwargs\n        )\n    else:\n        text = cast(str, self._create_reply(text))\n        return await self.say_scheduled(when, text, attachments=attachments, blocks=blocks, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.message.Message.reply_dm","title":"<code>reply_dm(text: str | None = None, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Reply to the sender of the original message with a DM</p> <p>Reply in a Direct Message to the sender of the original message by opening a DM channel and sending a message to it. Allows for rich formatting using <code>blocks</code> and/or <code>attachments</code>. You can provide blocks and attachments as Python dicts or you can use the <code>convenient classes</code> that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the <code>chat.postMessage</code> request.</p> <p>.. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes:     https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>message text</p> <code>None</code> <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see <code>attachments</code>_)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see <code>blocks</code>_)</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from <code>chat.postMessage</code>_ request.  .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage</p> Source code in <code>machine/plugins/message.py</code> <pre><code>async def reply_dm(\n    self,\n    text: str | None = None,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n\"\"\"Reply to the sender of the original message with a DM\n\n    Reply in a Direct Message to the sender of the original message by opening a DM channel and\n    sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_.\n    You can provide blocks and attachments as Python dicts or you can use the\n    `convenient classes`_ that the underlying slack client provides.\n    Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request.\n\n    .. _attachments: https://api.slack.com/docs/message-attachments\n    .. _blocks: https://api.slack.com/reference/block-kit/blocks\n    .. _convenient classes:\n        https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes\n\n    :param text: message text\n    :param attachments: optional attachments (see `attachments`_)\n    :param blocks: optional blocks (see `blocks`_)\n    :return: Dictionary deserialized from `chat.postMessage`_ request.\n\n    .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage\n    \"\"\"\n    return await self._client.send_dm(self.sender.id, text, attachments=attachments, blocks=blocks, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.message.Message.reply_dm_scheduled","title":"<code>reply_dm_scheduled(when: datetime, text: str, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Schedule a DM reply and send it</p> <p>This is the scheduled version of :py:meth:<code>~machine.plugins.base.Message.reply_dm</code>. It behaves the same, but will send the DM at the scheduled time.</p> <p>Parameters:</p> Name Type Description Default <code>when</code> <code>datetime</code> <p>when you want the message to be sent, as :py:class:<code>datetime.datetime</code> instance</p> required <code>text</code> <code>str</code> <p>message text</p> required <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see <code>attachments</code>_)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see <code>blocks</code>_)</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>None  .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks</p> Source code in <code>machine/plugins/message.py</code> <pre><code>async def reply_dm_scheduled(\n    self,\n    when: datetime,\n    text: str,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n\"\"\"Schedule a DM reply and send it\n\n    This is the scheduled version of :py:meth:`~machine.plugins.base.Message.reply_dm`.\n    It behaves the same, but will send the DM at the scheduled time.\n\n    :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance\n    :param text: message text\n    :param attachments: optional attachments (see `attachments`_)\n    :param blocks: optional blocks (see `blocks`_)\n    :return: None\n\n    .. _attachments: https://api.slack.com/docs/message-attachments\n    .. _blocks: https://api.slack.com/reference/block-kit/blocks\n    \"\"\"\n    return await self._client.send_dm_scheduled(\n        when, self.sender.id, text=text, attachments=attachments, blocks=blocks, **kwargs\n    )\n</code></pre>"},{"location":"api/#machine.plugins.message.Message.react","title":"<code>react(emoji: str) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>React to the original message</p> <p>Add a reaction to the original message</p> <p>Parameters:</p> Name Type Description Default <code>emoji</code> <code>str</code> <p>what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.)</p> required <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from <code>reactions.add</code>_ request.  .. _reactions.add: https://api.slack.com/methods/reactions.add</p> Source code in <code>machine/plugins/message.py</code> <pre><code>async def react(self, emoji: str) -&gt; AsyncSlackResponse:\n\"\"\"React to the original message\n\n    Add a reaction to the original message\n\n    :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.)\n    :return: Dictionary deserialized from `reactions.add`_ request.\n\n    .. _reactions.add: https://api.slack.com/methods/reactions.add\n    \"\"\"\n    return await self._client.react(self.channel.id, self._msg_event[\"ts\"], emoji)\n</code></pre>"},{"location":"api/#machine.plugins.message.Message.pin_message","title":"<code>pin_message() -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Pin message</p> <p>Pin the current message in the channel it was posted in</p> Source code in <code>machine/plugins/message.py</code> <pre><code>async def pin_message(self) -&gt; AsyncSlackResponse:\n\"\"\"Pin message\n\n    Pin the current message in the channel it was posted in\n    \"\"\"\n    return await self._client.pin_message(self.channel, self.ts)\n</code></pre>"},{"location":"api/#machine.plugins.command.Command","title":"<code>machine.plugins.command.Command</code>","text":"<p>A Slack command that was received by the bot</p> <p>This class represents a Slack command that was received by the bot and passed to a plugin. It contains the text that was included when the command was invoked, and metadata about the command, such as the user that invoked the command, the channel the command was invoked in.</p> <p>The <code>Command</code> class also contains convenience methods for sending messages in the right channel, opening modals etc.</p> Source code in <code>machine/plugins/command.py</code> <pre><code>class Command:\n\"\"\"A Slack command that was received by the bot\n\n    This class represents a Slack command that was received by the bot and passed to a plugin.\n    It contains the text that was included when the command was invoked, and metadata about\n    the command, such as the user that invoked the command, the channel the command was invoked\n    in.\n\n    The `Command` class also contains convenience methods for sending messages in the right\n    channel, opening modals etc.\n    \"\"\"\n\n    # TODO: create proper class for cmd_event\n    def __init__(self, client: SlackClient, cmd_payload: dict[str, Any]):\n        self._client = client\n        self._cmd_payload = cmd_payload\n        self._webhook_client = AsyncWebhookClient(self._cmd_payload[\"response_url\"])\n\n    @property\n    def sender(self) -&gt; User:\n\"\"\"The sender of the message\n\n        :return: the User the message was sent by\n        \"\"\"\n        return self._client.users[self._cmd_payload[\"user_id\"]]\n\n    @property\n    def channel(self) -&gt; Channel:\n\"\"\"The channel the message was sent to\n\n        :return: the Channel the message was sent to\n        \"\"\"\n        return self._client.channels[self._cmd_payload[\"channel_id\"]]\n\n    @property\n    def is_dm(self) -&gt; bool:\n        channel_id = self._cmd_payload[\"channel_id\"]\n        return not (channel_id.startswith(\"C\") or channel_id.startswith(\"G\"))\n\n    @property\n    def text(self) -&gt; str:\n\"\"\"The body of the actual message\n\n        :return: the body (text) of the actual message\n        \"\"\"\n        return self._cmd_payload[\"text\"]\n\n    @property\n    def command(self) -&gt; str:\n\"\"\"The command that was invoked\n\n        :return: the command that was invoked\n        \"\"\"\n        return self._cmd_payload[\"command\"]\n\n    @property\n    def response_url(self) -&gt; str:\n\"\"\"The response url associated with the command\n\n        This is a unique url for this specific command invocation.\n        It can be used for sending messages in response to the command.\n        This can only be used 5 times within 30 minutes of receiving the payload.\n\n        :return: the response url associated with the command\n        \"\"\"\n        return self._cmd_payload[\"response_url\"]\n\n    @property\n    def trigger_id(self) -&gt; str:\n\"\"\"The trigger id associated with the command\n\n        The trigger id can be used to trigger modals\n\n        :return: the trigger id associated with the command\n        \"\"\"\n        return self._cmd_payload[\"trigger_id\"]\n\n    async def say(\n        self,\n        text: str | None = None,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        ephemeral: bool = True,\n        **kwargs: Any,\n    ) -&gt; WebhookResponse:\n\"\"\"Send a new message to the channel the command was invoked in\n\n        Send a new message to the channel the command was invoked in, using the response_url as a webhook.\n        Allows for rich formatting using [blocks] and/or [attachments] . You can provide blocks\n        and attachments as Python dicts or you can use the [convenient classes] that the\n        underlying slack client provides.\n        This will send an ephemeral message by default, only visible to the user that invoked the command.\n        You can set `ephemeral` to `False` to make the message visible to everyone in the channel\n        Any extra kwargs you provide, will be passed on directly to `AsyncWebhookClient.send()`\n\n        [attachments]: https://api.slack.com/docs/message-attachments\n        [blocks]: https://api.slack.com/reference/block-kit/blocks\n        [convenient classes]: https://github.com/slackapi/python-slack-sdk/tree/main/slack/web/classes\n\n        :param text: message text\n        :param attachments: optional attachments (see [attachments])\n        :param blocks: optional blocks (see [blocks])\n        :param ephemeral: `True/False` wether to send the message as an ephemeral message, only\n            visible to the sender of the original message\n        :return: Dictionary deserialized from `AsyncWebhookClient.send()`\n\n        \"\"\"\n        if ephemeral:\n            response_type = \"ephemeral\"\n        else:\n            response_type = \"in_channel\"\n\n        return await self._webhook_client.send(\n            text=text, attachments=attachments, blocks=blocks, response_type=response_type, **kwargs\n        )\n</code></pre>"},{"location":"api/#machine.plugins.command.Command.sender","title":"<code>sender: User</code>  <code>property</code>","text":"<p>The sender of the message</p> <p>Returns:</p> Type Description <p>the User the message was sent by</p>"},{"location":"api/#machine.plugins.command.Command.channel","title":"<code>channel: Channel</code>  <code>property</code>","text":"<p>The channel the message was sent to</p> <p>Returns:</p> Type Description <p>the Channel the message was sent to</p>"},{"location":"api/#machine.plugins.command.Command.text","title":"<code>text: str</code>  <code>property</code>","text":"<p>The body of the actual message</p> <p>Returns:</p> Type Description <p>the body (text) of the actual message</p>"},{"location":"api/#machine.plugins.command.Command.command","title":"<code>command: str</code>  <code>property</code>","text":"<p>The command that was invoked</p> <p>Returns:</p> Type Description <p>the command that was invoked</p>"},{"location":"api/#machine.plugins.command.Command.response_url","title":"<code>response_url: str</code>  <code>property</code>","text":"<p>The response url associated with the command</p> <p>This is a unique url for this specific command invocation. It can be used for sending messages in response to the command. This can only be used 5 times within 30 minutes of receiving the payload.</p> <p>Returns:</p> Type Description <p>the response url associated with the command</p>"},{"location":"api/#machine.plugins.command.Command.trigger_id","title":"<code>trigger_id: str</code>  <code>property</code>","text":"<p>The trigger id associated with the command</p> <p>The trigger id can be used to trigger modals</p> <p>Returns:</p> Type Description <p>the trigger id associated with the command</p>"},{"location":"api/#machine.plugins.command.Command.say","title":"<code>say(text: str | None = None, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, ephemeral: bool = True, **kwargs: Any) -&gt; WebhookResponse</code>  <code>async</code>","text":"<p>Send a new message to the channel the command was invoked in</p> <p>Send a new message to the channel the command was invoked in, using the response_url as a webhook. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. This will send an ephemeral message by default, only visible to the user that invoked the command. You can set <code>ephemeral</code> to <code>False</code> to make the message visible to everyone in the channel Any extra kwargs you provide, will be passed on directly to <code>AsyncWebhookClient.send()</code></p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>message text</p> <code>None</code> <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see [attachments])</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see [blocks])</p> <code>None</code> <code>ephemeral</code> <code>bool</code> <p><code>True/False</code> wether to send the message as an ephemeral message, only visible to the sender of the original message</p> <code>True</code> <p>Returns:</p> Type Description <code>WebhookResponse</code> <p>Dictionary deserialized from <code>AsyncWebhookClient.send()</code></p> Source code in <code>machine/plugins/command.py</code> <pre><code>async def say(\n    self,\n    text: str | None = None,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    ephemeral: bool = True,\n    **kwargs: Any,\n) -&gt; WebhookResponse:\n\"\"\"Send a new message to the channel the command was invoked in\n\n    Send a new message to the channel the command was invoked in, using the response_url as a webhook.\n    Allows for rich formatting using [blocks] and/or [attachments] . You can provide blocks\n    and attachments as Python dicts or you can use the [convenient classes] that the\n    underlying slack client provides.\n    This will send an ephemeral message by default, only visible to the user that invoked the command.\n    You can set `ephemeral` to `False` to make the message visible to everyone in the channel\n    Any extra kwargs you provide, will be passed on directly to `AsyncWebhookClient.send()`\n\n    [attachments]: https://api.slack.com/docs/message-attachments\n    [blocks]: https://api.slack.com/reference/block-kit/blocks\n    [convenient classes]: https://github.com/slackapi/python-slack-sdk/tree/main/slack/web/classes\n\n    :param text: message text\n    :param attachments: optional attachments (see [attachments])\n    :param blocks: optional blocks (see [blocks])\n    :param ephemeral: `True/False` wether to send the message as an ephemeral message, only\n        visible to the sender of the original message\n    :return: Dictionary deserialized from `AsyncWebhookClient.send()`\n\n    \"\"\"\n    if ephemeral:\n        response_type = \"ephemeral\"\n    else:\n        response_type = \"in_channel\"\n\n    return await self._webhook_client.send(\n        text=text, attachments=attachments, blocks=blocks, response_type=response_type, **kwargs\n    )\n</code></pre>"},{"location":"api/#decorators","title":"Decorators","text":"<p>These are the decorators you can use to have Slack Machine respond to specific things (events, messages, etc.)</p>"},{"location":"api/#machine.plugins.decorators","title":"<code>machine.plugins.decorators</code>","text":""},{"location":"api/#machine.plugins.decorators.process","title":"<code>process(slack_event_type: str) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code>","text":"<p>Process Slack events of a specific type</p> <p>This decorator will enable a Plugin method to process <code>Slack events</code>_ of a specific type. The Plugin method will be called for each event of the specified type that the bot receives. The received event will be passed to the method when called.</p> <p>.. _Slack events: https://api.slack.com/events</p> <p>Parameters:</p> Name Type Description Default <code>slack_event_type</code> <code>str</code> <p>type of event the method needs to process. Can be any event supported by the RTM API</p> required <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code> <p>wrapped method</p> Source code in <code>machine/plugins/decorators.py</code> <pre><code>def process(slack_event_type: str) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]:\n\"\"\"Process Slack events of a specific type\n\n    This decorator will enable a Plugin method to process `Slack events`_ of a specific type. The\n    Plugin method will be called for each event of the specified type that the bot receives.\n    The received event will be passed to the method when called.\n\n    .. _Slack events: https://api.slack.com/events\n\n    :param slack_event_type: type of event the method needs to process. Can be any event supported\n        by the RTM API\n    :return: wrapped method\n    \"\"\"\n\n    def process_decorator(f: Callable[P, R]) -&gt; DecoratedPluginFunc[P, R]:\n        fn = cast(DecoratedPluginFunc, f)\n        fn.metadata = getattr(f, \"metadata\", Metadata())\n        fn.metadata.plugin_actions.process.append(slack_event_type)\n        return fn\n\n    return process_decorator\n</code></pre>"},{"location":"api/#machine.plugins.decorators.interactive","title":"<code>interactive(interactive_action_id: str) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code>","text":"<p>Process Interactive messages with specific action id</p> <p>This decorator will enable a Plugin method to process <code>Interactive Actions</code>_ of a specific action_id. The plugin method will be called for each interactive payload with the specified action_id in the actions block of an interactive message type that the bot receives. The received event will be passed to the method when called.</p> <p>.. _Slack interactive block-action payloads: https://api.slack.com/reference/interaction-payloads/block-actions</p> <p>Parameters:</p> Name Type Description Default <code>action_id</code> <p>The action_id from the actions list in an interactive payload</p> required <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code> <p>wrapped method</p> Source code in <code>machine/plugins/decorators.py</code> <pre><code>def interactive(interactive_action_id: str) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]:\n\"\"\"Process Interactive messages with specific action id\n\n    This decorator will enable a Plugin method to process `Interactive Actions`_ of a specific action_id.\n    The plugin method will be called for each interactive payload with the specified action_id in the\n    actions block of an interactive message type that the bot receives.\n    The received event will be passed to the method when called.\n\n    .. _Slack interactive block-action payloads: https://api.slack.com/reference/interaction-payloads/block-actions\n\n    :param action_id: The action_id from the actions list in an interactive payload\n    :return: wrapped method\n    \"\"\"\n\n    def interactive_decorator(f: Callable[P, R]) -&gt; DecoratedPluginFunc[P, R]:\n        fn = cast(DecoratedPluginFunc, f)\n        fn.metadata = getattr(f, \"metadata\", Metadata())\n        fn.metadata.plugin_actions.interactive.append(\n            InteractiveConfig(\n                action_id=interactive_action_id,\n            )\n        )\n        return fn\n\n    return interactive_decorator\n</code></pre>"},{"location":"api/#machine.plugins.decorators.view","title":"<code>view(interactive_callback_id: str) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code>","text":"<p>Process Interactive View messages with specific callback_id</p> <p>This decorator will enable a Plugin method to process <code>Interactive view_submissions</code>_ of a specific callback_id. The plugin method will be called for each interactive payload with the specified callback_id in the view block of an interactive view_submission message type that the bot receives. The received event will be passed to the method when called.</p> <p>.. _Slack ineractive view payloads: https://api.slack.com/reference/interaction-payloads/views</p> <p>Parameters:</p> Name Type Description Default <code>callback_id</code> <p>The callback_id from the view dict in an interactive payload</p> required <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code> <p>wrapped method</p> Source code in <code>machine/plugins/decorators.py</code> <pre><code>def view(interactive_callback_id: str) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]:\n\"\"\"Process Interactive View messages with specific callback_id\n\n    This decorator will enable a Plugin method to process `Interactive view_submissions`_ of a specific callback_id.\n    The plugin method will be called for each interactive payload with the specified callback_id in the\n    view block of an interactive view_submission message type that the bot receives.\n    The received event will be passed to the method when called.\n\n    .. _Slack ineractive view payloads: https://api.slack.com/reference/interaction-payloads/views\n\n    :param callback_id: The callback_id from the view dict in an interactive payload\n    :return: wrapped method\n    \"\"\"\n\n    def view_decorator(f: Callable[P, R]) -&gt; DecoratedPluginFunc[P, R]:\n        fn = cast(DecoratedPluginFunc, f)\n        fn.metadata = getattr(f, \"metadata\", Metadata())\n        fn.metadata.plugin_actions.view.append(ViewConfig(callback_id=interactive_callback_id))\n        return fn\n\n    return view_decorator\n</code></pre>"},{"location":"api/#machine.plugins.decorators.listen_to","title":"<code>listen_to(regex: str, flags: re.RegexFlag | int = re.IGNORECASE, handle_message_changed: bool = False) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code>","text":"<p>Listen to messages matching a regex pattern</p> <p>This decorator will enable a Plugin method to listen to messages that match a regex pattern. The Plugin method will be called for each message that matches the specified regex pattern. The received :py:class:<code>~machine.plugins.base.Message</code> will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called.</p> <p>Parameters:</p> Name Type Description Default <code>regex</code> <code>str</code> <p>regex pattern to listen for</p> required <code>flags</code> <code>RegexFlag | int</code> <p>regex flags to apply when matching</p> <code>IGNORECASE</code> <code>handle_message_changed</code> <code>bool</code> <p>if changed messages should trigger the decorated function</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code> <p>wrapped method</p> Source code in <code>machine/plugins/decorators.py</code> <pre><code>def listen_to(\n    regex: str, flags: re.RegexFlag | int = re.IGNORECASE, handle_message_changed: bool = False\n) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]:\n\"\"\"Listen to messages matching a regex pattern\n\n    This decorator will enable a Plugin method to listen to messages that match a regex pattern.\n    The Plugin method will be called for each message that matches the specified regex pattern.\n    The received :py:class:`~machine.plugins.base.Message` will be passed to the method when called.\n    Named groups can be used in the regex pattern, to catch specific parts of the message. These\n    groups will be passed to the method as keyword arguments when called.\n\n    :param regex: regex pattern to listen for\n    :param flags: regex flags to apply when matching\n    :param handle_message_changed: if changed messages should trigger the decorated function\n    :return: wrapped method\n    \"\"\"\n\n    def listen_to_decorator(f: Callable[P, R]) -&gt; DecoratedPluginFunc[P, R]:\n        fn = cast(DecoratedPluginFunc, f)\n        fn.metadata = getattr(f, \"metadata\", Metadata())\n        fn.metadata.plugin_actions.listen_to.append(MatcherConfig(re.compile(regex, flags), handle_message_changed))\n        return fn\n\n    return listen_to_decorator\n</code></pre>"},{"location":"api/#machine.plugins.decorators.respond_to","title":"<code>respond_to(regex: str, flags: re.RegexFlag | int = re.IGNORECASE, handle_message_changed: bool = False) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code>","text":"<p>Listen to messages mentioning the bot and matching a regex pattern</p> <p>This decorator will enable a Plugin method to listen to messages that are directed to the bot (ie. message starts by mentioning the bot) and match a regex pattern. The Plugin method will be called for each message that mentions the bot and matches the specified regex pattern. The received :py:class:<code>~machine.plugins.base.Message</code> will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called.</p> <p>Parameters:</p> Name Type Description Default <code>regex</code> <code>str</code> <p>regex pattern to listen for</p> required <code>flags</code> <code>RegexFlag | int</code> <p>regex flags to apply when matching</p> <code>IGNORECASE</code> <code>handle_message_changed</code> <code>bool</code> <p>if changed messages should trigger the decorated function</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code> <p>wrapped method</p> Source code in <code>machine/plugins/decorators.py</code> <pre><code>def respond_to(\n    regex: str, flags: re.RegexFlag | int = re.IGNORECASE, handle_message_changed: bool = False\n) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]:\n\"\"\"Listen to messages mentioning the bot and matching a regex pattern\n\n    This decorator will enable a Plugin method to listen to messages that are directed to the bot\n    (ie. message starts by mentioning the bot) and match a regex pattern.\n    The Plugin method will be called for each message that mentions the bot and matches the\n    specified regex pattern. The received :py:class:`~machine.plugins.base.Message` will be passed\n    to the method when called. Named groups can be used in the regex pattern, to catch specific\n    parts of the message. These groups will be passed to the method as keyword arguments when\n    called.\n\n    :param regex: regex pattern to listen for\n    :param flags: regex flags to apply when matching\n    :param handle_message_changed: if changed messages should trigger the decorated function\n    :return: wrapped method\n    \"\"\"\n\n    def respond_to_decorator(f: Callable[P, R]) -&gt; DecoratedPluginFunc[P, R]:\n        fn = cast(DecoratedPluginFunc, f)\n        fn.metadata = getattr(f, \"metadata\", Metadata())\n        fn.metadata.plugin_actions.respond_to.append(MatcherConfig(re.compile(regex, flags), handle_message_changed))\n        return fn\n\n    return respond_to_decorator\n</code></pre>"},{"location":"api/#machine.plugins.decorators.command","title":"<code>command(slash_command: str) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code>","text":"<p>Respond to a slash command</p> <p>This decorator will enable a Plugin method to respond to slash commands</p> <p>Parameters:</p> Name Type Description Default <code>slash_command</code> <code>str</code> <p>the slash command to respond to</p> required <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code> <p>wrapped method</p> Source code in <code>machine/plugins/decorators.py</code> <pre><code>def command(slash_command: str) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]:\n\"\"\"Respond to a slash command\n\n    This decorator will enable a Plugin method to respond to slash commands\n\n    :param slash_command: the slash command to respond to\n    :return: wrapped method\n    \"\"\"\n\n    def command_decorator(f: Callable[P, R]) -&gt; DecoratedPluginFunc[P, R]:\n        fn = cast(DecoratedPluginFunc, f)\n        fn.metadata = getattr(f, \"metadata\", Metadata())\n        if not slash_command.startswith(\"/\"):\n            normalized_slash_command = f\"/{slash_command}\"\n        else:\n            normalized_slash_command = slash_command\n        fn.metadata.plugin_actions.commands.append(\n            CommandConfig(command=normalized_slash_command, is_generator=inspect.isasyncgenfunction(f))\n        )\n        return fn\n\n    return command_decorator\n</code></pre>"},{"location":"api/#machine.plugins.decorators.schedule","title":"<code>schedule(year: int | str | None = None, month: int | str | None = None, day: int | str | None = None, week: int | str | None = None, day_of_week: int | str | None = None, hour: int | str | None = None, minute: int | str | None = None, second: int | str | None = None, start_date: datetime | str | None = None, end_date: datetime | str | None = None, timezone: tzinfo | str | None = None) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code>","text":"<p>Schedule a function to be executed according to a crontab-like schedule</p> <p>The decorated function will be executed according to the schedule provided. Slack Machine uses APScheduler under the hood for scheduling. For more information on the interpretation of the provided parameters, see :class:<code>CronTrigger&lt;apscheduler:apscheduler.triggers.cron.CronTrigger&gt;</code></p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int|str</code> <p>4-digit year</p> <code>None</code> <code>month</code> <code>int|str</code> <p>month (1-12)</p> <code>None</code> <code>day</code> <code>int|str</code> <p>day of the (1-31)</p> <code>None</code> <code>week</code> <code>int|str</code> <p>ISO week (1-53)</p> <code>None</code> <code>day_of_week</code> <code>int|str</code> <p>number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun)</p> <code>None</code> <code>hour</code> <code>int|str</code> <p>hour (0-23)</p> <code>None</code> <code>minute</code> <code>int|str</code> <p>minute (0-59)</p> <code>None</code> <code>second</code> <code>int|str</code> <p>second (0-59)</p> <code>None</code> <code>start_date</code> <code>datetime|str</code> <p>earliest possible date/time to trigger on (inclusive)</p> <code>None</code> <code>end_date</code> <code>datetime|str</code> <p>latest possible date/time to trigger on (inclusive)</p> <code>None</code> <code>timezone</code> <code>datetime.tzinfo|str</code> <p>time zone to use for the date/time calculations (defaults to scheduler timezone)</p> <code>None</code> Source code in <code>machine/plugins/decorators.py</code> <pre><code>def schedule(\n    year: int | str | None = None,\n    month: int | str | None = None,\n    day: int | str | None = None,\n    week: int | str | None = None,\n    day_of_week: int | str | None = None,\n    hour: int | str | None = None,\n    minute: int | str | None = None,\n    second: int | str | None = None,\n    start_date: datetime | str | None = None,\n    end_date: datetime | str | None = None,\n    timezone: tzinfo | str | None = None,\n) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]:\n\"\"\"Schedule a function to be executed according to a crontab-like schedule\n\n    The decorated function will be executed according to the schedule provided. Slack Machine uses\n    APScheduler under the hood for scheduling. For more information on the interpretation of the\n    provided parameters, see :class:`CronTrigger&lt;apscheduler:apscheduler.triggers.cron.CronTrigger&gt;`\n\n    :param int|str year: 4-digit year\n    :param int|str month: month (1-12)\n    :param int|str day: day of the (1-31)\n    :param int|str week: ISO week (1-53)\n    :param int|str day_of_week: number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun)\n    :param int|str hour: hour (0-23)\n    :param int|str minute: minute (0-59)\n    :param int|str second: second (0-59)\n    :param datetime|str start_date: earliest possible date/time to trigger on (inclusive)\n    :param datetime|str end_date: latest possible date/time to trigger on (inclusive)\n    :param datetime.tzinfo|str timezone: time zone to use for the date/time calculations (defaults\n        to scheduler timezone)\n    \"\"\"\n    kwargs = locals()\n\n    def schedule_decorator(f: Callable[P, R]) -&gt; DecoratedPluginFunc[P, R]:\n        fn = cast(DecoratedPluginFunc, f)\n        fn.metadata = getattr(f, \"metadata\", Metadata())\n        fn.metadata.plugin_actions.schedule = kwargs\n        return fn\n\n    return schedule_decorator\n</code></pre>"},{"location":"api/#machine.plugins.decorators.on","title":"<code>on(event: str) -&gt; Callable[[Callable[P, R]], Callable[P, R]]</code>","text":"<p>Listen for an event</p> <p>The decorated function will be called whenever a plugin (or Slack Machine itself) emits an event with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>str</code> <p>name of the event to listen for. Event names are global</p> required Source code in <code>machine/plugins/decorators.py</code> <pre><code>def on(event: str) -&gt; Callable[[Callable[P, R]], Callable[P, R]]:\n\"\"\"Listen for an event\n\n    The decorated function will be called whenever a plugin (or Slack Machine itself) emits an\n    event with the given name.\n\n    :param event: name of the event to listen for. Event names are global\n    \"\"\"\n\n    def on_decorator(f: Callable[P, R]) -&gt; Callable[P, R]:\n        ee.add_listener(event, f)\n        return f\n\n    return on_decorator\n</code></pre>"},{"location":"api/#machine.plugins.decorators.required_settings","title":"<code>required_settings(settings: list[str] | str) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code>","text":"<p>Specify a required setting for a plugin or plugin method</p> <p>The settings specified with this decorator will be added to the required settings for the plugin. If one or more settings have not been defined by the user, the plugin will not be loaded and a warning will be written to the console upon startup.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>list[str] | str</code> <p>settings that are required (can be list of strings, or single string)</p> required Source code in <code>machine/plugins/decorators.py</code> <pre><code>def required_settings(settings: list[str] | str) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]:\n\"\"\"Specify a required setting for a plugin or plugin method\n\n    The settings specified with this decorator will be added to the required settings for the\n    plugin. If one or more settings have not been defined by the user, the plugin will not be\n    loaded and a warning will be written to the console upon startup.\n\n    :param settings: settings that are required (can be list of strings, or single string)\n    \"\"\"\n\n    def required_settings_decorator(f_or_cls: Callable[P, R]) -&gt; DecoratedPluginFunc[P, R]:\n        casted_f_or_cls = cast(DecoratedPluginFunc, f_or_cls)\n        casted_f_or_cls.metadata = getattr(f_or_cls, \"metadata\", Metadata())\n        if isinstance(settings, list):\n            casted_f_or_cls.metadata.required_settings.extend(settings)\n        elif isinstance(settings, str):\n            casted_f_or_cls.metadata.required_settings.append(settings)\n        return casted_f_or_cls\n\n    return required_settings_decorator\n</code></pre>"},{"location":"api/#machine.plugins.decorators.require_any_role","title":"<code>require_any_role(required_roles: list[str]) -&gt; Callable[[Callable[..., Awaitable[None]]], Callable[..., Awaitable[None]]]</code>","text":"<p>Specify required roles for a plugin method</p> <p>To use the plugin method where this decorator is applied, the user must have at least one of the listed roles.</p> <p>Parameters:</p> Name Type Description Default <code>required_roles</code> <code>list[str]</code> <p>list of roles required to use the plugin method</p> required Source code in <code>machine/plugins/decorators.py</code> <pre><code>def require_any_role(\n    required_roles: list[str],\n) -&gt; Callable[[Callable[..., Awaitable[None]]], Callable[..., Awaitable[None]]]:\n\"\"\"Specify required roles for a plugin method\n\n    To use the plugin method where this decorator is applied, the user must have\n    at least one of the listed roles.\n\n    :param required_roles: list of roles required to use the plugin method\n    \"\"\"\n\n    def middle(func: Callable[..., Awaitable[None]]) -&gt; Callable[..., Awaitable[None]]:\n        async def wrapper(self: MachineBasePlugin, msg: Message, **kwargs: Any) -&gt; None:\n            if await matching_roles_by_user_id(self, msg.sender.id, required_roles):\n                logger.debug(f\"User {msg.sender} has one of the required roles {required_roles}\")\n                return await func(self, msg, **kwargs)\n            else:\n                logger.debug(f\"User {msg.sender} does not have any of the required roles {required_roles}\")\n                ee.emit(\n                    \"unauthorized-access\",\n                    self,\n                    message=msg,\n                    required_roles=required_roles,\n                    combinator=RoleCombinator.ANY,\n                )\n                await msg.say(\"I'm sorry, but you don't have access to that command\", ephemeral=True)\n                return None\n\n        # Copy any existing docs and metadata from container function to\n        # generated function\n        wrapper.__doc__ = func.__doc__\n        casted_wrapper = cast(DecoratedPluginFunc, wrapper)\n        casted_wrapper.metadata = getattr(func, \"metadata\", Metadata())\n        return casted_wrapper\n\n    return middle\n</code></pre>"},{"location":"api/#machine.plugins.decorators.require_all_roles","title":"<code>require_all_roles(required_roles: list[str]) -&gt; Callable[[Callable[..., Awaitable[None]]], Callable[..., Awaitable[None]]]</code>","text":"<p>Specify required roles for a plugin method</p> <p>To use the plugin method where this decorator is applied, the user must have all of the listed roles.</p> <p>Parameters:</p> Name Type Description Default <code>required_roles</code> <code>list[str]</code> <p>list of roles required to use the plugin method</p> required Source code in <code>machine/plugins/decorators.py</code> <pre><code>def require_all_roles(\n    required_roles: list[str],\n) -&gt; Callable[[Callable[..., Awaitable[None]]], Callable[..., Awaitable[None]]]:\n\"\"\"Specify required roles for a plugin method\n\n    To use the plugin method where this decorator is applied, the user must have\n    all of the listed roles.\n\n    :param required_roles: list of roles required to use the plugin method\n    \"\"\"\n\n    def middle(func: Callable[..., Awaitable[None]]) -&gt; Callable[..., Awaitable[None]]:\n        async def wrapper(self: MachineBasePlugin, msg: Message, **kwargs: Any) -&gt; None:\n            if await matching_roles_by_user_id(self, msg.sender.id, required_roles) == len(required_roles):\n                logger.debug(f\"User {msg.sender} has all of the required roles {required_roles}\")\n                return await func(self, msg, **kwargs)\n            else:\n                logger.debug(f\"User {msg.sender} does not have all of the required roles {required_roles}\")\n                ee.emit(\n                    \"unauthorized-access\",\n                    self,\n                    message=msg,\n                    required_roles=required_roles,\n                    combinator=RoleCombinator.ALL,\n                )\n                await msg.say(\"I'm sorry, but you don't have access to that command\", ephemeral=True)\n                return None\n\n        # Copy any existing docs and metadata from container function to\n        # generated function\n        wrapper.__doc__ = func.__doc__\n        casted_wrapper = cast(DecoratedPluginFunc, wrapper)\n        casted_wrapper.metadata = getattr(func, \"metadata\", Metadata())\n        return casted_wrapper\n\n    return middle\n</code></pre>"},{"location":"api/#models","title":"Models","text":"<p>These classes represent base objects from the Slack API</p>"},{"location":"api/#machine.models.user.User","title":"<code>machine.models.user.User</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>User model that represents a user object from the Slack API</p> Source code in <code>machine/models/user.py</code> <pre><code>class User(BaseModel):\n\"\"\"\n    User model that represents a user object from the Slack API\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    id: str\n    team_id: Optional[str] = None\n    name: str\n    deleted: Optional[bool] = None\n    profile: Profile\n    is_bot: bool\n    updated: int\n    is_app_user: bool\n    color: Optional[str] = None\n    real_name: Optional[str] = None\n    tz: Optional[str] = None\n    tz_label: Optional[str] = None\n    tz_offset: Optional[int] = None\n    is_admin: Optional[bool] = None\n    is_owner: Optional[bool] = None\n    is_primary_owner: Optional[bool] = None\n    is_restricted: Optional[bool] = None\n    is_ultra_restricted: Optional[bool] = None\n    is_stranger: Optional[bool] = None\n    has_2fa: Optional[bool] = None\n    locale: Optional[str] = None\n\n    def fmt_mention(self) -&gt; str:\n        return f\"&lt;@{self.id}&gt;\"\n</code></pre>"},{"location":"api/#machine.models.channel.Channel","title":"<code>machine.models.channel.Channel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Channel model that represents a channel object from the Slack API</p> Source code in <code>machine/models/channel.py</code> <pre><code>class Channel(BaseModel):\n\"\"\"\n    Channel model that represents a channel object from the Slack API\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    id: str\n    name: Optional[str] = None\n    created: int\n    creator: Optional[str] = None\n    is_archived: bool\n    is_general: Optional[bool] = None\n    name_normalized: Optional[str] = None\n    is_shared: Optional[bool] = None\n    is_org_shared: bool\n    is_member: Optional[bool] = None\n    is_private: Optional[bool] = None\n    is_mpim: Optional[bool] = None\n    is_channel: Optional[bool] = None\n    is_group: Optional[bool] = None\n    is_im: Optional[bool] = None\n    user: Optional[str] = None\n    topic: Optional[PurposeTopic] = None\n    purpose: Optional[PurposeTopic] = None\n    previous_names: Optional[List[str]] = None\n\n    @property\n    def identifier(self) -&gt; str:\n        if self.name:\n            return self.name\n        else:\n            return self.id\n</code></pre>"},{"location":"api/#storage","title":"Storage","text":"<p>Storage is exposed to plugins through the <code>self.storage</code> field. The following class implements the interface plugins can use to interact with the storage backend.</p> <p>New Storage Backends can be implemented by extending the following class:</p>"},{"location":"api/#machine.storage.PluginStorage","title":"<code>machine.storage.PluginStorage</code>","text":"<p>Class providing access to persistent storage for plugins</p> <p>This class is the main access point for plugins to work with persistent storage. It is accessible from plugins using <code>self.storage</code>. Data is serialized before sending it to the storage backend, and deserialized upon retrieval. Serialization is done by <code>dill</code>_, so pretty much any Python object can be stored and retrieved.</p> <p>.. _Dill: https://pypi.python.org/pypi/dill</p> Source code in <code>machine/storage/__init__.py</code> <pre><code>class PluginStorage:\n\"\"\"Class providing access to persistent storage for plugins\n\n    This class is the main access point for plugins to work with persistent storage. It is\n    accessible from plugins using ``self.storage``. Data is serialized before sending it to\n    the storage backend, and deserialized upon retrieval. Serialization is done by `dill`_, so\n    pretty much any Python object can be stored and retrieved.\n\n    .. _Dill: https://pypi.python.org/pypi/dill\n    \"\"\"\n\n    def __init__(self, fq_plugin_name: str, storage_backend: MachineBaseStorage):\n        self._fq_plugin_name = fq_plugin_name\n        self._storage = storage_backend\n\n    def _gen_unique_key(self, key: str) -&gt; str:\n        return f\"{self._fq_plugin_name}:{key}\"\n\n    def _namespace_key(self, key: str, shared: bool = False) -&gt; str:\n        return key if shared else self._gen_unique_key(key)\n\n    async def set(self, key: str, value: Any, expires: int | timedelta | None = None, shared: bool = False) -&gt; None:\n\"\"\"Store or update a value by key\n\n        :param key: the key under which to store the data\n        :param value: the data to store\n        :param expires: optional number of seconds after which the data is expired\n        :param shared: ``True/False`` wether this data should be shared by other plugins.  Use with\n            care, because it pollutes the global namespace of the storage.\n        \"\"\"\n        expires = int(expires.total_seconds()) if isinstance(expires, timedelta) else expires\n        namespaced_key = self._namespace_key(key, shared)\n        pickled_value = dill.dumps(value)\n        await self._storage.set(namespaced_key, pickled_value, expires)\n\n    async def get(self, key: str, shared: bool = False) -&gt; Any | None:\n\"\"\"Retrieve data by key\n\n        :param key: key for the data to retrieve\n        :param shared: ``True/False`` wether to retrieve data from the shared (global) namespace.\n        :return: the data, or ``None`` if the key cannot be found/has expired\n        \"\"\"\n        namespaced_key = self._namespace_key(key, shared)\n        value = await self._storage.get(namespaced_key)\n        if value:\n            return dill.loads(value)\n        else:\n            return None\n\n    async def has(self, key: str, shared: bool = False) -&gt; bool:\n\"\"\"Check if the key exists in storage\n\n        Note: this class implements ``__contains__`` so instead of calling\n        ``self.storage.has(...)``, you can also use: ``key in self.storage``. This will check the\n        *namespaced* version of the key, so it's the same as:\n        ``self.storage.has('key', shared=False)``\n\n        :param key: key to check\n        :param shared: ``True/False`` wether to check in the shared (global) namespace\n        :return: ``True/False`` wether the key exists. Can only return ``True`` if the key has not\n            expired.\n        \"\"\"\n        namespaced_key = self._namespace_key(key, shared)\n        return await self._storage.has(namespaced_key)\n\n    async def delete(self, key: str, shared: bool = False) -&gt; None:\n\"\"\"Remove a key and its data from storage\n\n        :param key: key to remove\n        :param shared: ``True/False`` wether the key to remove should be in the shared (global)\n            namespace\n        \"\"\"\n        namespaced_key = self._namespace_key(key, shared)\n        await self._storage.delete(namespaced_key)\n\n    async def get_storage_size(self) -&gt; int:\n\"\"\"Calculate the total size of the storage\n\n        :return: the total size of the storage in bytes (integer)\n        \"\"\"\n        return await self._storage.size()\n\n    async def get_storage_size_human(self) -&gt; str:\n\"\"\"Calculate the total size of the storage in human readable format\n\n        :return: the total size of the storage in a human readable string, rounded to the nearest\n            applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc.\n        \"\"\"\n        size = await self.get_storage_size()\n        return sizeof_fmt(size)\n</code></pre>"},{"location":"api/#machine.storage.PluginStorage.set","title":"<code>set(key: str, value: Any, expires: int | timedelta | None = None, shared: bool = False) -&gt; None</code>  <code>async</code>","text":"<p>Store or update a value by key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the key under which to store the data</p> required <code>value</code> <code>Any</code> <p>the data to store</p> required <code>expires</code> <code>int | timedelta | None</code> <p>optional number of seconds after which the data is expired</p> <code>None</code> <code>shared</code> <code>bool</code> <p><code>True/False</code> wether this data should be shared by other plugins.  Use with care, because it pollutes the global namespace of the storage.</p> <code>False</code> Source code in <code>machine/storage/__init__.py</code> <pre><code>async def set(self, key: str, value: Any, expires: int | timedelta | None = None, shared: bool = False) -&gt; None:\n\"\"\"Store or update a value by key\n\n    :param key: the key under which to store the data\n    :param value: the data to store\n    :param expires: optional number of seconds after which the data is expired\n    :param shared: ``True/False`` wether this data should be shared by other plugins.  Use with\n        care, because it pollutes the global namespace of the storage.\n    \"\"\"\n    expires = int(expires.total_seconds()) if isinstance(expires, timedelta) else expires\n    namespaced_key = self._namespace_key(key, shared)\n    pickled_value = dill.dumps(value)\n    await self._storage.set(namespaced_key, pickled_value, expires)\n</code></pre>"},{"location":"api/#machine.storage.PluginStorage.get","title":"<code>get(key: str, shared: bool = False) -&gt; Any | None</code>  <code>async</code>","text":"<p>Retrieve data by key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>key for the data to retrieve</p> required <code>shared</code> <code>bool</code> <p><code>True/False</code> wether to retrieve data from the shared (global) namespace.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any | None</code> <p>the data, or <code>None</code> if the key cannot be found/has expired</p> Source code in <code>machine/storage/__init__.py</code> <pre><code>async def get(self, key: str, shared: bool = False) -&gt; Any | None:\n\"\"\"Retrieve data by key\n\n    :param key: key for the data to retrieve\n    :param shared: ``True/False`` wether to retrieve data from the shared (global) namespace.\n    :return: the data, or ``None`` if the key cannot be found/has expired\n    \"\"\"\n    namespaced_key = self._namespace_key(key, shared)\n    value = await self._storage.get(namespaced_key)\n    if value:\n        return dill.loads(value)\n    else:\n        return None\n</code></pre>"},{"location":"api/#machine.storage.PluginStorage.has","title":"<code>has(key: str, shared: bool = False) -&gt; bool</code>  <code>async</code>","text":"<p>Check if the key exists in storage</p> <p>Note: this class implements <code>__contains__</code> so instead of calling <code>self.storage.has(...)</code>, you can also use: <code>key in self.storage</code>. This will check the namespaced version of the key, so it's the same as: <code>self.storage.has('key', shared=False)</code></p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>key to check</p> required <code>shared</code> <code>bool</code> <p><code>True/False</code> wether to check in the shared (global) namespace</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True/False</code> wether the key exists. Can only return <code>True</code> if the key has not expired.</p> Source code in <code>machine/storage/__init__.py</code> <pre><code>async def has(self, key: str, shared: bool = False) -&gt; bool:\n\"\"\"Check if the key exists in storage\n\n    Note: this class implements ``__contains__`` so instead of calling\n    ``self.storage.has(...)``, you can also use: ``key in self.storage``. This will check the\n    *namespaced* version of the key, so it's the same as:\n    ``self.storage.has('key', shared=False)``\n\n    :param key: key to check\n    :param shared: ``True/False`` wether to check in the shared (global) namespace\n    :return: ``True/False`` wether the key exists. Can only return ``True`` if the key has not\n        expired.\n    \"\"\"\n    namespaced_key = self._namespace_key(key, shared)\n    return await self._storage.has(namespaced_key)\n</code></pre>"},{"location":"api/#machine.storage.PluginStorage.delete","title":"<code>delete(key: str, shared: bool = False) -&gt; None</code>  <code>async</code>","text":"<p>Remove a key and its data from storage</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>key to remove</p> required <code>shared</code> <code>bool</code> <p><code>True/False</code> wether the key to remove should be in the shared (global) namespace</p> <code>False</code> Source code in <code>machine/storage/__init__.py</code> <pre><code>async def delete(self, key: str, shared: bool = False) -&gt; None:\n\"\"\"Remove a key and its data from storage\n\n    :param key: key to remove\n    :param shared: ``True/False`` wether the key to remove should be in the shared (global)\n        namespace\n    \"\"\"\n    namespaced_key = self._namespace_key(key, shared)\n    await self._storage.delete(namespaced_key)\n</code></pre>"},{"location":"api/#machine.storage.PluginStorage.get_storage_size","title":"<code>get_storage_size() -&gt; int</code>  <code>async</code>","text":"<p>Calculate the total size of the storage</p> <p>Returns:</p> Type Description <code>int</code> <p>the total size of the storage in bytes (integer)</p> Source code in <code>machine/storage/__init__.py</code> <pre><code>async def get_storage_size(self) -&gt; int:\n\"\"\"Calculate the total size of the storage\n\n    :return: the total size of the storage in bytes (integer)\n    \"\"\"\n    return await self._storage.size()\n</code></pre>"},{"location":"api/#machine.storage.PluginStorage.get_storage_size_human","title":"<code>get_storage_size_human() -&gt; str</code>  <code>async</code>","text":"<p>Calculate the total size of the storage in human readable format</p> <p>Returns:</p> Type Description <code>str</code> <p>the total size of the storage in a human readable string, rounded to the nearest applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc.</p> Source code in <code>machine/storage/__init__.py</code> <pre><code>async def get_storage_size_human(self) -&gt; str:\n\"\"\"Calculate the total size of the storage in human readable format\n\n    :return: the total size of the storage in a human readable string, rounded to the nearest\n        applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc.\n    \"\"\"\n    size = await self.get_storage_size()\n    return sizeof_fmt(size)\n</code></pre>"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage","title":"<code>machine.storage.backends.base.MachineBaseStorage</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for storage backends</p> <p>Extending classes should implement the five methods in this base class. Slack Machine takes care of a lot of details regarding the persistent storage of data. So storage backends do not have to deal with the following, because Slack Machine takes care of these:</p> <ul> <li>Serialization/Deserialization of data</li> <li>Namespacing of keys (so data stored by different plugins doesn't clash)</li> </ul> Source code in <code>machine/storage/backends/base.py</code> <pre><code>class MachineBaseStorage(ABC):\n\"\"\"Base class for storage backends\n\n    Extending classes should implement the five methods in this base class. Slack Machine takes\n    care of a lot of details regarding the persistent storage of data. So storage backends\n    **do not** have to deal with the following, because Slack Machine takes care of these:\n\n    - Serialization/Deserialization of data\n    - Namespacing of keys (so data stored by different plugins doesn't clash)\n    \"\"\"\n\n    settings: Mapping[str, Any]\n\n    def __init__(self, settings: Mapping[str, Any]):\n        self.settings = settings\n\n    async def init(self) -&gt; None:\n\"\"\"Initialize the storage backend\"\"\"\n        pass\n\n    @abstractmethod\n    async def get(self, key: str) -&gt; bytes | None:\n\"\"\"Retrieve data by key\n\n        :param key: key for which to retrieve data\n        :return: the raw data for the provided key, as (byte)string. Should return ``None`` when\n            the key is unknown or the data has expired.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    async def set(self, key: str, value: bytes, expires: int | None = None) -&gt; None:\n\"\"\"Store data by key\n\n        :param key: the key under which to store the data\n        :param value: data as (byte)string\n        :param expires: optional expiration time in seconds, after which the data should not be\n            returned any more.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    async def delete(self, key: str) -&gt; None:\n\"\"\"Delete data by key\n\n        :param key: key for which to delete the data\n        \"\"\"\n        ...\n\n    @abstractmethod\n    async def has(self, key: str) -&gt; bool:\n\"\"\"Check if the key exists\n\n        :param key: key to check\n        :return: ``True/False`` wether the key exists\n        \"\"\"\n        ...\n\n    @abstractmethod\n    async def size(self) -&gt; int:\n\"\"\"Calculate the total size of the storage\n\n        :return: total size of storage in bytes (integer)\n        \"\"\"\n        ...\n\n    @abstractmethod\n    async def close(self) -&gt; None:\n\"\"\"Close the storage backend\"\"\"\n        ...\n</code></pre>"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.init","title":"<code>init() -&gt; None</code>  <code>async</code>","text":"<p>Initialize the storage backend</p> Source code in <code>machine/storage/backends/base.py</code> <pre><code>async def init(self) -&gt; None:\n\"\"\"Initialize the storage backend\"\"\"\n    pass\n</code></pre>"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.get","title":"<code>get(key: str) -&gt; bytes | None</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Retrieve data by key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>key for which to retrieve data</p> required <p>Returns:</p> Type Description <code>bytes | None</code> <p>the raw data for the provided key, as (byte)string. Should return <code>None</code> when the key is unknown or the data has expired.</p> Source code in <code>machine/storage/backends/base.py</code> <pre><code>@abstractmethod\nasync def get(self, key: str) -&gt; bytes | None:\n\"\"\"Retrieve data by key\n\n    :param key: key for which to retrieve data\n    :return: the raw data for the provided key, as (byte)string. Should return ``None`` when\n        the key is unknown or the data has expired.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.set","title":"<code>set(key: str, value: bytes, expires: int | None = None) -&gt; None</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Store data by key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the key under which to store the data</p> required <code>value</code> <code>bytes</code> <p>data as (byte)string</p> required <code>expires</code> <code>int | None</code> <p>optional expiration time in seconds, after which the data should not be returned any more.</p> <code>None</code> Source code in <code>machine/storage/backends/base.py</code> <pre><code>@abstractmethod\nasync def set(self, key: str, value: bytes, expires: int | None = None) -&gt; None:\n\"\"\"Store data by key\n\n    :param key: the key under which to store the data\n    :param value: data as (byte)string\n    :param expires: optional expiration time in seconds, after which the data should not be\n        returned any more.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.delete","title":"<code>delete(key: str) -&gt; None</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Delete data by key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>key for which to delete the data</p> required Source code in <code>machine/storage/backends/base.py</code> <pre><code>@abstractmethod\nasync def delete(self, key: str) -&gt; None:\n\"\"\"Delete data by key\n\n    :param key: key for which to delete the data\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.has","title":"<code>has(key: str) -&gt; bool</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Check if the key exists</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>key to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True/False</code> wether the key exists</p> Source code in <code>machine/storage/backends/base.py</code> <pre><code>@abstractmethod\nasync def has(self, key: str) -&gt; bool:\n\"\"\"Check if the key exists\n\n    :param key: key to check\n    :return: ``True/False`` wether the key exists\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.size","title":"<code>size() -&gt; int</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Calculate the total size of the storage</p> <p>Returns:</p> Type Description <code>int</code> <p>total size of storage in bytes (integer)</p> Source code in <code>machine/storage/backends/base.py</code> <pre><code>@abstractmethod\nasync def size(self) -&gt; int:\n\"\"\"Calculate the total size of the storage\n\n    :return: total size of storage in bytes (integer)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.close","title":"<code>close() -&gt; None</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Close the storage backend</p> Source code in <code>machine/storage/backends/base.py</code> <pre><code>@abstractmethod\nasync def close(self) -&gt; None:\n\"\"\"Close the storage backend\"\"\"\n    ...\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, with a smattering of Common Changelog thrown in, most notably references, authors and prefixes. This project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#0350","title":"0.35.0","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Incoming requests/events from Slack that the Slack App is subscribed to, will be logged when <code>LOGLEVEL</code> is set to   <code>DEBUG</code> (#876)</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Breaking: the optional <code>init()</code> method of plugins is now expected to be <code>async</code>. This allows plugin authors to   interact with Slack during plugin initialization through Slack Machine's plugin API.   (#868)</li> <li>Standard app manifest for Slack Machine now also enables listening for the <code>app_home_opened</code> event</li> <li>Bump <code>aiosqlite</code> from 0.18.0 to 0.19.0</li> <li>Bump <code>apscheduler</code> from 3.10.1 to 3.10.4</li> <li>Bump <code>redis</code> from 4.6.0 to 5.0.0</li> <li>Bump <code>pyee</code> from 10.0.2 to 11.0.0</li> <li>Bump <code>pydantic</code> from 2.2.1 to 2.3.0</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Use conversations_setTopic instead of channels_setTopic for setting channel topic   (#869 by   @jogendra)</li> </ul>"},{"location":"changelog/#0342-2023-08-13","title":"0.34.2 - 2023-08-13","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Users indexed by email and related functions are now exposed through the plugin interface   (#852)</li> </ul>"},{"location":"changelog/#0341-2023-08-13","title":"0.34.1 - 2023-08-13","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Slack users are now indexed by their email as well, allowing fast lookups by email   (#849)</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>All logging in Slack Machine is now done through structlog instead of the Python stdlib logger   (#850)</li> </ul>"},{"location":"changelog/#0340-2023-08-13","title":"0.34.0 - 2023-08-13","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Add support to set topic on channels (#839 by   @jogendra)</li> <li>Add SQLite storage backend (#844 by   @cp-richard)</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Bump <code>httpx</code> from 0.24.0 to 0.24.1</li> <li>Bump <code>aiohttp</code> from 3.8.4 to 3.8.5</li> <li>Bump <code>certifi</code> from 2022.12.7 to 2023.7.22</li> <li>Bump <code>pyee</code> from 9.1.0 to 10.0.2</li> <li>Bump <code>pydantic</code> from 1.10.7 to 2.1.1 (#840)</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Breaking: Remove Python 3.7 support (#846)</li> </ul>"},{"location":"changelog/#0330-2023-05-15","title":"0.33.0 - 2023-05-15","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Add support for slash commands   (#787)</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Breaking: move <code>Message</code> class from <code>machine.plugins.base</code> to <code>machine.plugins.message</code></li> <li>Use dots only for referencing the fully-qualified name of classes and functions instead of using a colon before   the class name</li> <li>Bump <code>tzdata</code> from 2022.6 to 2023.3</li> <li>Bump <code>slack-sdk</code> from 3.19.4 to 3.21.3</li> <li>Bump <code>aioboto3</code> from 10.1.0 to 11.2.0</li> <li>Bump <code>aiohttp</code> from 3.8.3 to 3.8.4</li> <li>Bump <code>redis</code> from 4.3.5 to 4.5.5</li> <li>Bump <code>hiredis</code> from 2.0.0 to 2.2.3</li> <li>Bump <code>pydantic</code> from 1.10.2 to 1.10.7</li> <li>Bump <code>httpx</code> from 0.23.1 to 0.24.0</li> <li>Bump <code>apscheduler</code> from 3.9.1.post1 to 3.10.1</li> <li>Bump <code>structlog</code> from 22.3.0 to 23.1.0</li> <li>Bump <code>pyee</code> from 9.0.4 to 9.1.0</li> </ul>"},{"location":"changelog/#0320-2022-11-27","title":"0.32.0 - 2022-11-27","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Add Python 3.11 support (#676)</li> <li>Expose web client of Slack SDK (#677)</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Bump <code>dill</code> from 0.3.5.1 to 0.3.6</li> <li>Bump <code>slack-sdk</code> from 3.19.1 to 3.19.4</li> <li>Bump <code>tzdata</code> from 2022.5 to 2022.6</li> <li>Bump <code>apscheduler</code> from 3.9.1 to 3.9.1.post1</li> <li>Bump <code>httpx</code> from 0.23.0 to 0.23.1</li> <li>Bump <code>redis</code> from 4.3.4 to 4.3.5</li> <li>Bump <code>structlog</code> from 22.1.0 to 22.3.0</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Fix documentation typos (#665 by   @bennylu2)</li> </ul>"},{"location":"changelog/#0310-2022-10-21","title":"0.31.0 - 2022-10-21","text":""},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Moved Slack Machine community chat to Slack</li> <li>Type-hint coverage is now 100% so mypy is happy (#633)</li> <li>Update pyproject.toml to conform to Poetry 1.2 dependency specification   (#657)</li> <li>Replace <code>dacite</code> with <code>pydantic</code> to create models for Slack API interactions   (#659)</li> <li>Bump <code>aiohttp</code> from 3.8.1 to 3.8.3</li> <li>Bump <code>slack-sdk</code> from 3.18.3 to 3.19.1</li> <li>Bump <code>tzdata</code> from 2022.4 to 2022.5</li> <li>Bump <code>aioboto3</code> from 10.0.0 to 10.1.0</li> <li>Add changelog to keep track of updates</li> <li>Move to structlog for logging, fixes   #599   (#663)</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>Remove unused settings: <code>DISABLE_HTTP</code>, <code>HTTP_SERVER_HOST</code>, <code>HTTP_SERVER_PORT</code>, <code>HTTP_SERVER_BACKEND</code>, <code>HTTPS_PROXY</code>,   <code>KEEP_ALIVE</code></li> </ul>"},{"location":"changelog/#0300-2022-08-30","title":"0.30.0 - 2022-08-30","text":""},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Bump <code>slack-sdk</code> from 3.18.1 to 3.18.3 (#619)</li> </ul>"},{"location":"changelog/#removed_2","title":"Removed","text":"<ul> <li>Breaking: Remove sync version, it's all async now baby! :dancing_men:</li> </ul>"},{"location":"changelog/#0282-2022-08-30","title":"0.28.2 - 2022-08-30","text":""},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Make handling changed message configurable in async mode (#613)</li> <li>Add tests for slack client (#614)</li> </ul>"},{"location":"changelog/#0281-2022-08-28","title":"0.28.1 - 2022-08-28","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Add support for pinning/unpinning of messages (#611)</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Add support for listening to message change events (#594   with help from @cchadowitz-pf)</li> </ul>"},{"location":"changelog/#0280-2022-08-28","title":"0.28.0 - 2022-08-28","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Add support to async version for scheduling messages and running plugin functions on a schedule   (#610)</li> </ul>"},{"location":"changelog/#0272-2022-08-14","title":"0.27.2 - 2022-08-14","text":""},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li><code>aioboto3</code> types are only relevant for type checking, so move imports inside type checking guard</li> </ul>"},{"location":"changelog/#0271-2022-08-14","title":"0.27.1 - 2022-08-14","text":""},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Add documentation for DynamoDB storage backend (#603)</li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Add <code>aioboto3</code> as optional dependency so extras can be satisfied (#604)</li> </ul>"},{"location":"changelog/#0270-2022-08-14","title":"0.27.0 - 2022-08-14","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Add DynamoDB storage backend (#602 by   @jkmathes)</li> <li>Add <code>black</code>, <code>isort</code> and other linters/formatters to create uniform code style (#597)</li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>Update documentation for builtin plugins, fixes #396   (#598)</li> <li>Replace <code>requests</code> with <code>httpx</code> for async http calls in meme plugin and share memes as blocks   (#600)</li> <li>Replace <code>requests</code> with <code>httpx</code> for async http calls in Google image search plugin (#601)</li> </ul>"},{"location":"changelog/#0261-2022-08-13","title":"0.26.1 - 2022-08-13","text":""},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Various documentation fixes</li> <li>Fix project metadata</li> </ul>"},{"location":"changelog/#0260-2022-08-13","title":"0.26.0 - 2022-08-13","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>Slack Machine now supports asyncio using the Slack Events API   and Socket Mode! :racing_car:</li> </ul>"},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>Bump <code>redis</code> from 4.2.0 to 4.3.4</li> <li>Bump <code>slack-sdk</code> from 3.15.2 to 3.18.1</li> </ul>"},{"location":"changelog/#0250-2022-03-27","title":"0.25.0 - 2022-03-27","text":""},{"location":"changelog/#changed_11","title":"Changed","text":"<ul> <li>Bump <code>redis</code> from 4.0.2 to 4.2.0</li> <li>Bump <code>slack-sdk</code> from 3.12.0 to 3.15.2</li> <li>Bump <code>requests</code> from 2.26.0 to 2.27.1</li> <li>Bump <code>apscheduler</code> from 3.8.1 to 3.9.1</li> </ul>"},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Fix expected payload of events when updating channel cache, fixes #526   (#565)</li> </ul>"},{"location":"changelog/#0240-2021-12-01","title":"0.24.0 - 2021-12-01","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>Add Python 3.10 support</li> </ul>"},{"location":"changelog/#changed_12","title":"Changed","text":"<ul> <li>Bump <code>redis</code> from 3.5.3 to 4.0.2</li> <li>Bump <code>apscheduler</code> from 3.8.0 to 3.8.1</li> <li>Move documentation from Sphinx to MkDocs and Material for MkDocs   for beautiful docs (#514)</li> <li>Switch from <code>slackclient</code> to <code>slack_sdk</code> library, fixes #443</li> </ul>"},{"location":"changelog/#removed_3","title":"Removed","text":"<ul> <li>Breaking: Remove Python 3.6 support</li> </ul>"},{"location":"changelog/#0232-2021-10-17","title":"0.23.2 - 2021-10-17","text":""},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>Bring back script to run Slack Machine</li> </ul>"},{"location":"changelog/#0231-2021-10-17","title":"0.23.1 - 2021-10-17","text":""},{"location":"changelog/#changed_13","title":"Changed","text":"<ul> <li>Document all contributors</li> </ul>"},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>Install the right extra packages for Redis</li> </ul>"},{"location":"changelog/#removed_4","title":"Removed","text":"<ul> <li>Breaking: HBase storage backend has been removed</li> </ul>"},{"location":"changelog/#0230-2021-10-16","title":"0.23.0 - 2021-10-16","text":""},{"location":"changelog/#changed_14","title":"Changed","text":"<ul> <li>Switch to Poetry for project and dependency management</li> <li>Bump <code>apscheduler</code> from 3.7.0 to 3.8.0</li> </ul>"},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>Various CI fixes</li> </ul>"},{"location":"changelog/#0220-2021-09-12","title":"0.22.0 - 2021-09-12","text":""},{"location":"changelog/#changed_15","title":"Changed","text":"<ul> <li>Bump <code>dill</code> from 0.3.3 to 0.3.4</li> <li>Bump <code>requests</code> from 2.25.1 to 2.26.0</li> <li>Bump <code>cython</code> from 0.29.23 to 0.29.24</li> <li>Use Github Actions for CI and drop Travis (#492)</li> <li>Switch <code>master</code> branch to <code>main</code> to get with the times</li> </ul>"},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li>Only cover named channels when attempting to find a channel by name (#483   by @arusahni)</li> </ul>"},{"location":"changelog/#0211-2021-08-01","title":"0.21.1 - 2021-08-01","text":""},{"location":"changelog/#changed_16","title":"Changed","text":"<ul> <li>Add channel members to <code>Channel</code> model and keep members up-to-date through Slack events (#485   by @arusahni)</li> </ul>"},{"location":"changelog/#0210-2021-04-25","title":"0.21.0 - 2021-04-25","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li>Add Gitter chat room to facilitate discussions about Slack Machine</li> <li>Add Role-based access controls feature for plugins (#321   by @davidolrik)</li> <li>Add Python 3.9 support</li> </ul>"},{"location":"changelog/#changed_17","title":"Changed","text":"<ul> <li>Move to Dependabot from PyUp to manage automatic dependency updates</li> <li>Bump <code>slackclient</code> from 2.7.3 to 2.9.3</li> <li>Bump <code>requests</code> from 2.24.0 to 2.25.1</li> <li>Bump <code>dill</code> from 0.3.2 to 0.3.3</li> <li>Bump <code>dacite</code> from 1.5.1 to 1.6.0</li> <li>Bump <code>cython</code> from 0.29.21 to 0.29.23</li> <li>Bump <code>apscheduler</code> from 3.6.3 to 3.7.0</li> </ul>"},{"location":"changelog/#fixed_12","title":"Fixed","text":"<ul> <li>Make channel topic creator an optional field in the <code>Channel</code> model (#439   by @eguven)</li> <li>Always respond to plugin functions decorated with <code>@listen_to</code>, also when bot is addressed in direct message (#436   by @eddyg)</li> <li>Use <code>conversations.open</code> endpoint on Slack WebAPI instead of <code>im.open</code> endpoint to open direct message conversations,   because the latter is deprecated (#401   by @cchadowitz-pf)</li> </ul>"},{"location":"changelog/#0201-2020-07-23","title":"0.20.1 - 2020-07-23","text":""},{"location":"changelog/#fixed_13","title":"Fixed","text":"<ul> <li>Use <code>conversations.info</code> endpoint on Slack WebAPI instead of <code>channels.info</code> endpoint, which is deprecated and   mark optional fields as such in <code>User</code> and <code>Channel</code> objects   (#386 by @repudi8or)</li> </ul>"},{"location":"changelog/#0200-2020-07-22","title":"0.20.0 - 2020-07-22","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li>Support Python 3.8</li> </ul>"},{"location":"changelog/#changed_18","title":"Changed","text":"<ul> <li>Bump <code>dacite</code> from 1.0.2 to 1.5.1</li> <li>Bump <code>redis</code> from 3.3.11 to 3.5.3</li> <li>Bump <code>cython</code> from 0.29.14 to 0.29.21</li> <li>Bump <code>dill</code> from 0.3.1.1 to 0.3.2</li> <li>Bump <code>requests</code> from 2.22.0 to 2.24.0</li> <li>Bump <code>slackclient</code> from 2.5.0 to 2.7.3</li> <li>Add <code>is_thread</code> property to <code>Message</code> class (#286 by   @davidolrik)</li> <li>Use <code>conversations.list</code> endpoint on Slack WebAPI instead of <code>channels.list</code> endpoint, which is deprecated and   include private channels in channel cache (#329 by   @repudi8or)</li> <li>Include direct messages in channel cache</li> <li>Add pre-commit hooks to verify basic things before commiting</li> </ul>"},{"location":"changelog/#fixed_14","title":"Fixed","text":"<ul> <li><code>deleted</code> property is optional on user responses from Slack WebAPI</li> </ul>"},{"location":"changelog/#0192-2020-01-05","title":"0.19.2 - 2020-01-05","text":""},{"location":"changelog/#changed_19","title":"Changed","text":"<ul> <li>Breaking:: <code>thread_ts</code> property on the <code>Message</code> class has been renamed to <code>ts</code></li> </ul>"},{"location":"changelog/#fixed_15","title":"Fixed","text":"<ul> <li><code>EchoPlugin</code> will not respond to itself anymore</li> <li>Fixed PyPI classifiers</li> </ul>"},{"location":"changelog/#0191-2020-01-05","title":"0.19.1 - 2020-01-05","text":""},{"location":"changelog/#fixed_16","title":"Fixed","text":"<ul> <li>Fix help plugin</li> <li>Fix various typos in the documentation</li> </ul>"},{"location":"changelog/#0190-2020-01-05","title":"0.19.0 - 2020-01-05","text":""},{"location":"changelog/#changed_20","title":"Changed","text":"<ul> <li>Major version upgrade of <code>slackclient</code> from 1.3.1 to 2.5.0</li> <li>Refactor code to capture Slack API responses in dataclasses for easier development</li> <li>Split internal Slack client into low-level client and high-level facade</li> <li>Start adding type hints</li> <li>Breaking: <code>self.users</code> and <code>self.channels</code> on the base plugin class now return different objects than before.   See API documentation for more details. These properties should behave more consistently however, even in workspaces   with many users.</li> </ul>"},{"location":"changelog/#removed_5","title":"Removed","text":"<ul> <li>Breaking: Remove <code>catch_all()</code> method from base plugin class because it's not supported by the <code>slackclient</code>   library anymore</li> <li>Breaking: The <code>*_webapi</code> methods to send messages do not exist anymore, use the regular counterparts instead. All   messages are now sent using the Slack WebAPI. The RTM API is still used for listening to messages and events</li> </ul>"},{"location":"changelog/#0182-2019-11-17","title":"0.18.2 - 2019-11-17","text":""},{"location":"changelog/#fixed_17","title":"Fixed","text":"<ul> <li>Fix <code>bottle</code> import</li> </ul>"},{"location":"changelog/#0181-2019-11-17","title":"0.18.1 - 2019-11-17","text":""},{"location":"changelog/#changed_21","title":"Changed","text":"<ul> <li>Bump <code>apscheduler</code> from 3.5.3 to 3.6.3</li> <li>Bump <code>redis</code> from 3.2.0 to 3.3.11</li> <li>Bump <code>happybase</code> from 1.1.0 to 1.2.0</li> <li>Bump <code>cython</code> from 0.29.6 to 0.29.14</li> <li>Bump <code>dill</code> from 0.2.9 to 0.3.1.1</li> <li>Bump <code>bottle</code> from 0.12.16 to 0.12.17</li> <li>Include <code>bottle</code> as a vendored dependency to not be dependent on the long release cycles of <code>bottle</code></li> <li>Fix deprecation warnings to prepare for Python 3.8</li> <li>Allow matching multiline messages in <code>@listen_to</code> and <code>@respond_to</code> decorators (#178   by @seerickcode)</li> </ul>"},{"location":"changelog/#removed_6","title":"Removed","text":"<ul> <li>Breaking: drop support for Python 3.4 and 3.5</li> </ul>"},{"location":"changelog/#0180-2019-03-10","title":"0.18.0 - 2019-03-10","text":""},{"location":"changelog/#changed_22","title":"Changed","text":"<ul> <li>Bump <code>slackclient</code> from 1.3.0 to 1.3.1</li> <li>Bump <code>dill</code> from 0.2.8.2 to 0.2.9</li> <li>Bump <code>bottle</code> from 0.12.13 to 0.12.16</li> <li>Bump <code>redis</code> from 2.10.6 to 3.2.0</li> <li>Bump <code>Cython</code> from 0.28.5 to 0.29.6</li> </ul>"},{"location":"changelog/#0170-2018-11-10","title":"0.17.0 - 2018-11-10","text":""},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li>Add support for bot aliases (#108   by @seerickcode)</li> </ul>"},{"location":"changelog/#0161-2018-09-28","title":"0.16.1 - 2018-09-28","text":""},{"location":"changelog/#changed_23","title":"Changed","text":"<ul> <li>Allow not only direct subclasses of MachineBasePlugin be plugins, but also deeper decendants (#95   by @gfreezy)</li> <li>Bump <code>slackclient</code> from 1.2.1 to 1.3.0 (#88)</li> </ul>"},{"location":"changelog/#0160-2018-09-06","title":"0.16.0 - 2018-09-06","text":""},{"location":"changelog/#added_13","title":"Added","text":"<ul> <li>Add HBase storage backend</li> </ul>"},{"location":"changelog/#0150-2018-09-03","title":"0.15.0 - 2018-09-03","text":""},{"location":"changelog/#added_14","title":"Added","text":"<ul> <li>Add optional keep-alive ping in background thread to keep the connection to Slack alive (#79   by @preludedrew)</li> </ul> <p>This helps when Slack Machine is running in environments that occasionally \"go to sleep\", such as Heroku</p>"},{"location":"changelog/#changed_24","title":"Changed","text":"<ul> <li>Bump <code>apscheduler</code> from 3.5.1 to 3.5.3</li> <li>Fix Python 3.7 builds by using Xenial distro</li> </ul>"},{"location":"changelog/#0140-2018-07-31","title":"0.14.0 - 2018-07-31","text":""},{"location":"changelog/#added_15","title":"Added","text":"<ul> <li>Add Python 3.7 support</li> </ul>"},{"location":"changelog/#changed_25","title":"Changed","text":"<ul> <li>Add support for configuring HTTP proxy for Slack client (#69   by @gfreezy)</li> </ul>"},{"location":"changelog/#0132-2018-07-04","title":"0.13.2 - 2018-07-04","text":""},{"location":"changelog/#changed_26","title":"Changed","text":"<ul> <li>Make HTTP server host &amp; port configurable (#64 by   @pirogoeth)</li> <li>Bump <code>dill</code> from 0.2.7.1 to 0.2.8.2</li> <li>Bump <code>slackclient</code> from 1.1.3 to 1.2.1</li> </ul>"},{"location":"changelog/#0131-2018-03-06","title":"0.13.1 - 2018-03-06","text":""},{"location":"changelog/#changed_27","title":"Changed","text":"<ul> <li>Mention webserver functionality in README</li> </ul>"},{"location":"changelog/#0130-2018-03-06-yanked","title":"0.13.0 - 2018-03-06 [YANKED]","text":"<p>:warning: NOTE: release was yanked due to lack of documentation</p>"},{"location":"changelog/#added_16","title":"Added","text":"<ul> <li>Add webserver functionality so plugins can have functions triggered by HTTP requests</li> </ul>"},{"location":"changelog/#changed_28","title":"Changed","text":"<ul> <li>Bump <code>slackclient</code> from 1.1.2 to 1.1.3</li> </ul>"},{"location":"changelog/#0122-2018-02-26","title":"0.12.2 - 2018-02-26","text":""},{"location":"changelog/#changed_29","title":"Changed","text":"<ul> <li>Bump <code>slackclient</code> from 1.1.0 to 1.1.2</li> <li>Memes plugin: support custom meme templates</li> </ul>"},{"location":"changelog/#fixed_18","title":"Fixed","text":"<ul> <li>Plugin help now properly distinguishes between robot or human help</li> </ul>"},{"location":"changelog/#0121-2018-01-26","title":"0.12.1 - 2018-01-26","text":""},{"location":"changelog/#fixed_19","title":"Fixed","text":"<ul> <li>Fix tests for new plugins</li> </ul>"},{"location":"changelog/#0120-2018-01-26","title":"0.12.0 - 2018-01-26","text":""},{"location":"changelog/#added_17","title":"Added","text":"<ul> <li>Add Google Image search plugin</li> <li>Add memes plugin based on Memegen</li> </ul>"},{"location":"changelog/#0110-2018-01-22","title":"0.11.0 - 2018-01-22","text":""},{"location":"changelog/#added_18","title":"Added","text":"<ul> <li>Add help feature so users can see what a bot can do based on documentation provided by plugin authors</li> </ul>"},{"location":"changelog/#0100-2018-01-21","title":"0.10.0 - 2018-01-21","text":""},{"location":"changelog/#added_19","title":"Added","text":"<ul> <li>Add optional plugin initialization</li> <li>Allow plugins to mark settings as required</li> </ul>"},{"location":"changelog/#changed_30","title":"Changed","text":"<ul> <li>Bump <code>apscheduler</code> from 3.4.0 to 3.5.1</li> </ul>"},{"location":"changelog/#090-2017-12-03","title":"0.9.0 - 2017-12-03","text":""},{"location":"changelog/#changed_31","title":"Changed","text":"<ul> <li>Bump <code>apscheduler</code> from 3.3.1 to 3.4.0</li> <li>Bump <code>slackclient</code> from 1.0.9 to 1.1.0</li> <li>WebAPI methods will return deserialized API responses (#14   by @pirogoeth)</li> </ul>"},{"location":"changelog/#removed_7","title":"Removed","text":"<ul> <li>Breaking: drop support for Python 3.3</li> </ul>"},{"location":"changelog/#080-2017-10-15","title":"0.8.0 - 2017-10-15","text":""},{"location":"changelog/#added_20","title":"Added","text":"<ul> <li>Add support for event listeners and emitting events for inter-plugin communication</li> </ul>"},{"location":"changelog/#070-2017-10-13","title":"0.7.0 - 2017-10-13","text":""},{"location":"changelog/#added_21","title":"Added","text":"<ul> <li>Add scheduling functionality to send messages and run plugin functions on a schedule</li> </ul>"},{"location":"changelog/#changed_32","title":"Changed","text":"<ul> <li>Refactor client classes to be singletons so they don't need to be persisted by APScheduler</li> <li>Add PyUp to automatically update dependencies</li> </ul>"},{"location":"changelog/#060-2017-09-14","title":"0.6.0 - 2017-09-14","text":""},{"location":"changelog/#added_22","title":"Added","text":"<ul> <li>Add pluggable plugin storage so plugins can store data</li> <li>Add 2 storage backends: in-memory and Redis</li> </ul>"},{"location":"changelog/#changed_33","title":"Changed","text":"<ul> <li>Drastically improve tests and increase coverage</li> </ul>"},{"location":"changelog/#050-2017-09-09","title":"0.5.0 - 2017-09-09","text":""},{"location":"changelog/#changed_34","title":"Changed","text":"<ul> <li>Finish documentation</li> </ul>"},{"location":"changelog/#040-2017-09-06","title":"0.4.0 - 2017-09-06","text":""},{"location":"changelog/#added_23","title":"Added","text":"<ul> <li>Document how to create plugins + plugin API</li> </ul>"},{"location":"changelog/#changed_35","title":"Changed","text":"<ul> <li>Decorators can now be used multiple times on the same function</li> </ul>"},{"location":"changelog/#030-2017-09-03","title":"0.3.0 - 2017-09-03","text":""},{"location":"changelog/#added_24","title":"Added","text":"<ul> <li>Basic documentation</li> </ul>"},{"location":"changelog/#020-2017-09-01","title":"0.2.0 - 2017-09-01","text":""},{"location":"changelog/#added_25","title":"Added","text":"<ul> <li>Add tests and CI</li> </ul>"},{"location":"changelog/#010-2017-08-29","title":"0.1.0 - 2017-08-29","text":"<p>First release. Rejoice! :wave:</p>"},{"location":"changelog/#added_26","title":"Added","text":"<ul> <li>A simple, yet powerful and extendable Slack bot framework</li> </ul>"},{"location":"migrating/","title":"Migrating plugins to async","text":"<p>As of v0.30.0 Slack Machine dropped support for the old backend based on the RTM API. As such, Slack Machine is now fully based on AsyncIO. This means plugins written before the rewrite to asyncio aren't supported anymore. This is a migration guide to get your old plugins working with the new version of Slack Machine.</p>"},{"location":"migrating/#await-all-slack-machine-plugin-functions","title":"Await all Slack Machine plugin functions","text":"<p>Any function from <code>MachineBasePlugin</code> and <code>Message</code> needs to be awaited now. This is as easy as prefixing your the function calls with the <code>await</code> keyword:</p> <pre><code>await self.say(\"#general\", \"Hello there baby!\")\n</code></pre>"},{"location":"migrating/#all-of-your-plugin-functions-need-to-be-async","title":"All of your plugin functions need to be async","text":"<p>Because you're awaiting methods from the Slack Machine plugin classes now, the functions you define in your own plugins, need to be async. This is as easy as prefixing your function definitions with the <code>async</code> keyword:</p> <pre><code>class MyPlugin(MachineBasePlugin):\n    @listen_to(r\"^hello\")\n    async def hello(self, msg):\n        msg.say(\"world\")\n</code></pre>"},{"location":"plugins/basics/","title":"Plugin Basics","text":"<p>Writing plugins for Slack Machine is easy. To show you how easy, we'll build and run a simple plugin from start to finish. To be able to follow this guide, you have to have installed and configured Slack Machine first!</p>"},{"location":"plugins/basics/#the-base-class-for-plugins","title":"The Base class for plugins","text":"<p>Plugins in Slack Machine are classes that subclass <code>MachineBasePlugin</code>. Inheriting from this class tells Slack Machine that we're dealing with a plugin. But that's not even the most exciting part! With this base class, your plugin immediately has a lot of functionality at its disposal that makes it super easy to do anything from talking to channels, responding to messages, sending DMs, and much more!</p>"},{"location":"plugins/basics/#the-decorators","title":"The decorators","text":"<p>Being able to talk in Slack is only half the story for plugins. The functions in your plugin have to be triggered somehow. Slack Machine provides decorators for that. You can decorate the functions in your plugin class to tell them what they should react to.</p> <p>As an example, let's create a cool plugin!</p>"},{"location":"plugins/basics/#step-1-creating-the-plugin","title":"Step 1: Creating the plugin","text":"<p>We're going to create a plugin that listens for The Answer, and responds in kind.</p> <p>In the root of your bot (where your <code>local_settings.py</code> lives), create a plugins folder. In it, create an <code>__init__.py</code> (so your plugins folder becomes a package) and a file named <code>hitchhikers.py</code>.</p> <p>Your folder structure should look like this:</p> <pre><code>\u251c\u2500\u2500 local_settings.py\n\u2514\u2500\u2500 plugins\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 hitchhikers.py\n</code></pre>"},{"location":"plugins/basics/#step-2-adding-the-code","title":"Step 2: Adding the code","text":"<p>First, we should import the <code>MachineBasePlugin</code> in our code, and the decorator to listen for specific messages. Then we can create our plugin class that includes a function that listens for The Answer, and responds to it:</p> <pre><code>from machine.plugins.base import MachineBasePlugin\nfrom machine.plugins.decorators import listen_to\nimport re\n\nclass UltimateQuestionPlugin(MachineBasePlugin):\n\n    @listen_to(regex=r\"^42$\")\n    async def question(self, msg):\n        await msg.say(\"You're telling me the Answer to the Ultimate Question of Life, the Universe and Everything, \",\n                      \"but I don't know the question :cry:\")\n</code></pre> <p>Tip</p> <p>As Slack-Machine is fully built on top of Python's excellent AsyncIO library, all of the functionality that Slack Machine offers (e.g. sending messages, adding reactions etc.) comes in the form of async functions, a.k.a. coroutines. This means that the plugin functions you define, have to be coroutines as well!</p> <p>This will take a while to get used to, but the reward is that Slack Machine is able to run your plugin functions concurrently.</p>"},{"location":"plugins/basics/#step-3-enabling-our-plugin","title":"Step 3: Enabling our plugin","text":"<p>Now we can enable our plugin in our configuration file. Your <code>local_settings.py</code> should look like this:</p> <pre><code>SLACK_APP_TOKEN = \"xapp-my-app-token\"\nSLACK_BOT_TOKEN = \"xoxb-my-bot-token\"\n\nPLUGINS = [\"machine.plugins.builtin.general.HelloPlugin\",\n           \"machine.plugins.builtin.general.PingPongPlugin\",\n           \"plugins.hitchhikers.UltimateQuestionPlugin\"]\n</code></pre>"},{"location":"plugins/basics/#step-4-run-that-bot","title":"Step 4: Run that bot!","text":"<p>To run your bot with the new plugin:</p> <pre><code>$ slack-machine\n</code></pre> <p>That's all there is to it!</p>"},{"location":"plugins/interacting/","title":"How to interact","text":"<p>Slack Machine provides several convenient ways to interact with channels and users in your Slack workspace. To this end, two very similar sets of functions are exposed through two classes:</p>"},{"location":"plugins/interacting/#machinebaseplugin","title":"MachineBasePlugin","text":"The <code>MachineBasePlugin</code> class every plugin extends, provides methods to send messages to channels (public, private and DM), using the WebAPI, with support for rich messages/blocks/attachment. It also supports adding reactions to messages, pinning and unpinning messages, replying in-thread, sending ephemeral messages to a channel (only visible to 1 user), and much more."},{"location":"plugins/interacting/#message","title":"Message","text":"An instance of the <code>Message</code> class is automatically supplied to your plugin functions when using the <code>@respond_to</code> or <code>@respond_to</code> decorators. It has a similar set of methods as the <code>MachineBasePlugin</code> class, but without the need to manually specify the channel you want to talk to. It lets you send messages and reply to messages in the same channel the original message was received in. <p>It is recommended to use the passed-in <code>Message</code> object to interact with channels and users, whenever you use the <code>@respond_to</code> or <code>@respond_to</code> decorators, as this takes away the pain of having to manually target the right channels.</p> <p>For a detailed description of all the methods available to you, please read the api documentation. What follows are some examples of how you would respond in common scenarios.</p>"},{"location":"plugins/interacting/#responding-to-a-message","title":"Responding to a message","text":"If your plugin receives a message through the <code>@respond_to</code> or <code>@listen_to</code> decorators, the simplest way to reply is using <code>msg.reply()</code>. It takes 2 parameters: <p>text: the message you want to send</p> <p>in_thread: if Slack Machine should reply to the original message in-thread</p> <p><code>msg.reply()</code> will start the reply with a mention of the sender of the original message.</p> <p>Example:</p> <pre><code>@respond_to(r\"^I love you\")\nasync def spread_love(self, msg):\n    await msg.reply(\"I love you too!\")\n</code></pre> <p>If this function is triggered by a message @superbot I love you, sent by @john, the response will be: @john: I love you too!</p> <p><code>msg.reply()</code> will use the Slack WebAPI to send messages, which means you can send richly formatted messages using blocks and/or attachments.</p> <p>The underlying Python slack-sdk that Slack Machine uses, provides some convenience classes that can help with creating blocks or attachments. All Slack Machine methods that can be used to send messages, accept lists of <code>Block</code> objects and/or <code>Attachment</code> objects from the aforementioned convience classes.</p> This method has 2 extra parameters that unlock 2 extra features: <p>ephemeral: if <code>True</code>, the message will be visible only to the sender of the original message.</p> <p>in_thread: this will send the message in a thread instead of to the main channel</p> <p>There is 1 more method to respond to a message in the same channel: <code>msg.say()</code> is very similar to its <code>reply</code> counterpart, with the exception that it won't mention the sender of the original message.</p> <p>If you want to reply to the sender of the original message in a DM instead of in the original channel, you can use the <code>msg.reply_dm()</code> methods. This will open a DM convo between the sender of the original message and the bot (if it doesn't exist already) and send a message there. If the original message was already received in a DM channel, this is no different from using <code>reply()</code>.</p>"},{"location":"plugins/interacting/#message-properties","title":"Message properties","text":"The <code>Message</code> object your plugin function receives, has some convenient properties about the message that triggered the function: <p>sender: a <code>User</code> object with information about the sender, such as their <code>id</code> and <code>name</code></p> <p>channel: a Channel object with information about the channel the message was received in</p> <p>text: the contents of the original message</p>"},{"location":"plugins/interacting/#plugin-properties","title":"Plugin properties","text":"The <code>MachineBasePlugin</code> class every plugin extends, exposes some properties about your Slack workspace. These properties are not filled when your plugin is instantiated, but reflect the current status of the Slack client: <p>users: a dict of user ids and the associated <code>User</code> objects for all users that Slack Machine knows about. This is usually all the active users in your Slack workspace. This data structure is filled when Slack Machine starts and is automatically updated whenever a new user joins or the properties of a user change.</p> <p>channels: a dict of channel ids and the associated <code>User</code> objects for channels that Slack Machine knows about. This contains all the public channels in your Slack workspace, plus all private channels that your Slack Machine instance was invited to.</p>"},{"location":"plugins/interacting/#sending-messages-without-a-msg-object","title":"Sending messages without a msg object","text":"<p>There are situations in which you want to send messages to users/channels, but there is no original message to respond to. For example when implementing your own event listener using the <code>@process</code> decorator. In this case you can call functions similar as those described before, but from your plugin itself: <code>self.say()</code> and <code>self.send_dm()</code>.</p> <p>These behave similar to their <code>Message</code> counterparts, except that they require a channel id or object, or user id or object (in case of DM) to be passed in. You can use <code>find_channel_by_name()</code> to find the channel you want to send a message to.</p>"},{"location":"plugins/interacting/#scheduling-messages","title":"Scheduling messages","text":"<p>Sometimes you want to reply to a message, send a message to some channel, send a DM etc. but you don't want to do it now. You want to do it in the future. Slack Machine provides scheduled versions of many methods, both in the <code>MachineBasePlugin</code> all plugins extend from and in the <code>Message</code> object <code>@respond_to</code> and <code>@respond_to</code> functions receive. These methods can be recognized by their _scheduled prefix. They work almost the same as their regular counterparts, except that they receive 1 extra argument: a <code>datetime</code> object that tells Slack Machine when to send the message.</p> <p>Example:</p> <pre><code>@respond_to(r\"greet me in the future\")\nasync def future(self, msg):\n    await msg.say(\"command received!\")\n    in_10_sec = datetime.now() + timedelta(seconds=10)\n    await msg.reply_dm_scheduled(in_10_sec, \"A Delayed Hello!\")\n</code></pre> <p>This function will send a greeting 10 seconds after it has received a message: @superbot greet me in the future.</p> <p>Caveat</p> <p>You cannot schedule a reaction to a message. It doesn't make sense to react to a message in the future.</p> <p>For more information about scheduling message, have a look at the api documentation.</p>"},{"location":"plugins/interacting/#protecting-commands","title":"Protecting commands","text":"<p>Sometimes you may want to restrict certain commands in your bot, so they can only be invoked by certain users.</p> <p>To use these restrictions you must appoint one user to be the root user. For security reasons there can be only one root user, and it must be configured through <code>local_settings.py</code> or environment variables. That way you will never lose control over your bot.</p> <p>To enable all the role based features, your <code>local_settings.py</code> would look something like this:</p> <pre><code>SLACK_APP_TOKEN = \"xapp-my-app-token\"\nSLACK_BOT_TOKEN = \"xoxb-my-bot-token\"\nROOT_USER = \"0000007\"\nPLUGINS = [\n    'machine.plugins.builtin.admin.RBACPlugin',\n]\n</code></pre> <p>You can get the member ID from a user by going to their Slack profile, clicking more and selecting Copy member ID.</p> <p>If you wish to share the powers of root you can enable the RBAC admin plugin <code>machine.plugins.builtin.admin.RBACPlugin</code> and grant the admin role to users you trust.</p> <p>The RBAC plugin provides you with three new commands that lets you lookup, grant and revoke roles to users:</p> <ul> <li>@superbot who has role admin</li> <li>@superbot grant role admin to @trusted-user</li> <li>@superbot revoke role admin from @trusted-user.</li> </ul> <p>Now you can decorate certain functions in your plugin with the <code>@require_any_role</code> or <code>@require_all_roles</code> decorators to make them only usable by users with certain roles.</p> <p>Here is an example of a command that requires either the admin or channel role:</p> <pre><code>@respond_to(\n    r\"^say in\"\n    r\"\\s+&lt;#\\w+\\|(?P&lt;channel_name&gt;[^&gt;]+)&gt;\"\n    r\"\\s+(?P&lt;message&gt;.+)\"\n)\n@require_any_role([\"admin\", \"channel\"])\nasync def say_in_channel(self, msg, channel_name, message):\n    logging.info(channel_name)\n    await self.say(channel_name, message)\n</code></pre> <p>You can define as many roles as you want, any string without spaces is acceptable.</p>"},{"location":"plugins/interacting/#emitting-events","title":"Emitting events","text":"<p>Your plugin can emit arbitrary events that other plugins (or your own) can listen for. Events are a convenient mechanism for exchanging data between plugins and/or for a plugin to expose an api that other plugins can hook into. Emitting an event is done with <code>self.emit()</code>. You have to provide a name for the event you want to emit, so others can listen for an event by that name. You can optionally provide extra data as keyword arguments.</p> <p>Example:</p> <pre><code>@respond_to(r\"I have used the bathroom\")\nasync def broadcast_bathroom_usage(self, msg):\n    self.emit('bathroom_used', toilet_flushed=True)\n</code></pre> <p>You can read the events section to see how your plugin can listen for events.</p>"},{"location":"plugins/interacting/#using-the-slack-web-api-in-other-ways","title":"Using the Slack Web API in other ways","text":"<p>Sometimes you want to use Slack Web API in ways that are not directly exposed by <code>MachineBaserPlugin</code>. In these cases you can use <code>self.web_client</code>. <code>self.web_client</code> references the <code>AsyncWebClient</code> object of the underlying Slack Python SDK.</p>"},{"location":"plugins/listening/","title":"Listening for things","text":"<p>Slack Machine allows you to listen for various different things and respond to that. By decorating functions in your plugin using the decorators Slack Machine provides, you can tell Slack Machine to run those functions when something specific happens.</p>"},{"location":"plugins/listening/#listen-for-a-mention","title":"Listen for a mention","text":"<p>The <code>respond_to</code> decorator tells Slack Machine to listen for messages mentioning your bot and matching a specific pattern. Slack Machine will hear messages sent in any channel or private group it is a member of. For a message to trigger a function decorated by <code>@respond_to(...)</code>, the message has to start with a mention of your bot or with any alias the user configured using the <code>ALIASES</code> setting. The exception is direct messages sent to the bot, they don't have to include a mention to trigger <code>@respond_to</code>.</p> <code>@respond_to</code> takes 3 parameters: <p>regex (required): the regular expression Slack Machine should listen for. The regex pattern should not account for the mention of your bot, as Slack Machine will remove the mention before looking for a match. Slack Machine listens for any occurrence of the pattern in the message, so if you want to specifically match the whole message, you can anchor your pattern using the <code>^</code> and <code>$</code> symbols.</p> <p>flags (optional): can be used to pass flags for the regex matching as defined in the <code>re</code> module. By default, <code>re.IGNORECASE</code> is applied.</p> <p>handle_message_changed (optional): is used to configure if Slack Machine should trigger this function for messages that have been changed. By default, only new messages will trigger the decorated function.</p>"},{"location":"plugins/listening/#how-your-function-will-be-called","title":"How your function will be called","text":"<p>Your function will be called with a <code>Message</code> object that represents the message that triggered the function. It not only contains the message text itself, but also has many convenient methods for replying.</p> <p>Example:</p> <pre><code>@respond_to(r\"^I love you\")\nasync def spread_love(self, msg):\n    await msg.reply(\"I love you too!\")\n</code></pre> <p>The regex pattern can optionally contain named groups that will be captured and passed to your function as keyword arguments.</p> <p>Example:</p> <pre><code>@respond_to(r\"You deserve (?P&lt;num_stars&gt;\\d+) stars!\")\nasync def award(self, msg, num_stars):\n    stars_back = int(num_stars) + 1\n    await msg.reply(\"Well, you deserve {}!\".format(stars_back))\n</code></pre>"},{"location":"plugins/listening/#hear-any-message","title":"Hear any message","text":"<p>The <code>@listen_to</code> decorator works similar as the <code>@respond_to</code> decorator, but it will hear any message matching a pattern, without the bot being explicitly mentioned. <code>@listen_to</code> takes the same parameters as <code>@respond_to</code>.</p> <p>Example:</p> <pre><code>@listen_to(r\"go for it\")\n@listen_to(r\"go 4 it\")\nasync def go_for_it(self, msg):\n    await msg.say(\"https://a-z-animals.com/media/animals/images/original/gopher_2.jpg\")\n</code></pre> <p>As you can see, you can also apply the same decorator multiple times to a function, each time with different arguments. Of course, you can also combine different decorators on one function.</p>"},{"location":"plugins/listening/#more-flexibility-with-slack-events","title":"More flexibility with Slack events","text":"<p>If you want your bot to respond to other things than messages, you can do so using the <code>@process</code> decorator. <code>@process</code> requires an <code>event_type</code> as parameter and will trigger the decorated function any time an event of the specified type happens. It can listen to any Slack event that is supported by the Events API.</p> <p>The received event will be passed to your function.</p> <p>The following example will listen for the reaction_added event to know if a reaction was added to a message, and will match that reaction:</p> <pre><code>@process(\"reaction_added\")\nasync def match_reaction(self, event):\n    emoji = event[\"reaction\"]\n    channel = event[\"item\"][\"channel\"]\n    ts = event[\"item\"][\"ts\"]\n    await self.react(channel, ts, emoji)\n</code></pre> <p>As you can see, <code>@process</code> gives you a lot of flexibility by allowing you to process any event Slack Machine does not provide a specific decorator for.</p>"},{"location":"plugins/listening/#take-action-on-a-schedule","title":"Take action on a Schedule","text":"<p>Slack Machine can also run functions on a schedule, using the <code>@schedule</code> decorator. <code>@schedule</code> behaves like Linux/Unix Crontab, and receives similar parameters. You can specify on what schedule your function should be called. When your function is called, it will not receive any arguments except <code>self</code>, but you can of course call any <code>MachineBasePlugin</code> methods to send message and do other things.</p> <p>Example:</p> <pre><code>@schedule(hour=\"9-17\", minute=\"*/30\")\nasync def movement_reminder(self):\n    await self.say(\"general\", \"&lt;!here&gt; maybe now is a good time to take a short walk!\")\n</code></pre>"},{"location":"plugins/listening/#slack-machine-events","title":"Slack Machine events","text":"<p>Slack Machine can respond to events that are emitted by your plugin(s) or plugins of others, or events generated by parts of Slack Machine itself. You can use the <code>@on</code> decorator on a function to run that function whenever a certain event is emitted somewhere.</p> <p>Example:</p> <pre><code>@on(\"bathroom_used\")\nasync def call_cleaning_department(self, **kwargs):\n    await self.say(\"cleaning-department\", \"&lt;!here&gt; Somebody used the toilet!\")\n</code></pre> <p>This function will be called whenever the <code>bathroom_used</code> event is emitted somewhere.</p> <p>Some things to be aware of</p> <p>Event names are global, every plugin can emit and listen for the same events. This is by design, because this way, you can use events to exchange data between plugins. Events can be a way to expose a \"public API\" for plugins. But this can also mean your functions are unexpectedly triggered by events sent by other plugins, especially if the event names you choose are very generic.</p> <p>When emitting events, plugins can attach whatever variables they want to the event, and when listening for an event, your function will be called with whatever arguments were attached to the event when the event was emitted. It's therefor a good idea to always include <code>**kwargs</code> as a catch-all, otherwise your function could return an error when it's called with arguments that have not been explicitly defined.</p> <p>So what is this event system useful for? As mentioned in the above note, events can be used to communicate between plugins and/or for plugins to respond to events that happen within the core of Slack Machine. A good example of this, is the <code>unauthorized-access</code> event. This event will be emitted whenever someone tries to use a bot command protected by the <code>require_any_role</code> or <code>require_all_roles</code> decorators without having the right roles to issue that command. By listening to this event, your plugins can take action when this happens. The built-in RBAC plugin also listens for this event.</p> <p>You can read emitting events to learn how to emit events from your own plugins.</p>"},{"location":"plugins/misc/","title":"Miscellaneous stuff","text":"<p>This section contains some odds and ends that were not discussed in previous sections.</p>"},{"location":"plugins/misc/#plugin-initialization","title":"Plugin initialization","text":"<p>Plugins are initialized when Slack Machine starts. Because the <code>MachineBasePlugin</code> already has a constructor that is used to pass various things to the plugin instance at startup, it is advised not to provide a constructor for your plugin.</p> <p>If your plugin needs to initialize its own things at startup, you can override the <code>init()</code> method. This method will be called once when the plugin is initialized. It is no-op by default. If you choose to implement this method, make sure it is <code>async</code>. This allows you to use the async plugin API of Slack Machine to interact with Slack and also lets you use the plugin storage.</p> <p>When the <code>init()</code> methods of plugins are called, the underlying Slack client has already been initialized, so you should have full access to all Slack-related information, incl. a populated list of <code>users</code> and <code>channels</code></p>"},{"location":"plugins/misc/#logging","title":"Logging","text":"<p>Slack Machine uses structlog for logging. In your plugins, you can instantiate and use a logger as follows:</p> <pre><code>from structlog.stdlib import get_logger\n\nlogger = get_logger(__name__)\n\n\nasync def my_function():\n    logger.info(\"Running my function\", foo=42, bar=\"hello\")\n</code></pre>"},{"location":"plugins/misc/#logging-message-handler-invocations","title":"Logging message handler invocations","text":"<p>By default, Slack Machine will log anytime a Slack message triggers a handler in a plugin. This log statement will include the message that triggered the handler and the user id &amp; name of the user that posted the message.</p> <p>You can disable these log message by setting <code>LOG_HANDLED_MESSAGES</code> to <code>False</code> in your <code>local_settings.py</code></p>"},{"location":"plugins/misc/#using-loggers-provided-by-slack-machine-in-your-handler-functions","title":"Using loggers provided by Slack Machine in your handler functions","text":"<p>Structlog allows adding extra parameters as context. Slack Machine leverages this to bind the id and name of the user who sent a message to a logger as context variables whenever a message triggers a handler function. You can opt-in to using this logger, by adding a <code>logger</code> parameter to your handler function.</p> <pre><code>async def my_handler(msg, logger):\n    logger.info(\"my_handler invoked!\")\n</code></pre> <p>Slack Machine will automatically inject a logger with the right context variables into your handler. The example will produce a message like:</p> <pre><code>2022-10-21T14:29:05.639162Z [info] my_handler invoked! [example_plugin.my_plugin.MyPlugin.my_handler] filename=my_plugin.py func_name=my_handler lineno=5 user_id=U12345678 user_name=user1\n</code></pre> <p>This currently works for handler functions that are decorated with <code>respond_to</code>, <code>listen_to</code> or <code>command</code></p>"},{"location":"plugins/misc/#plugin-help-information","title":"Plugin help information","text":"<p>You can provide help text for your plugin and its commands by adding docstrings to your plugin class and its methods. The first line of the docstring of a plugin class will be used for grouping help information of plugin methods. This even extends beyond one class, ie. if multiple plugin classes have the same docstring (first line), the help information for the methods under those classes will be grouped together.</p> <p>The first line of the docstring of each plugin method can be used for specifying help information for that specific function. It should be in the format <code>command: help text</code>.</p> <p>The <code>machine.plugins.builtin.help.HelpPlugin</code> (enabled by default) will provide Slack users with the help information described above.</p>"},{"location":"plugins/settings/","title":"Plugin Settings","text":"<p>All settings that are defined, either from the Slack Machine defaults or in <code>local_settings.py</code> are available to plugins through the <code>self.settings</code> field. This is a dictionary with all settings indexed by their name. Next to <code>local_settings.py</code>, users can also specify settings with environment variables. Slack Machine will automatically translate any environment variable with the format <code>SM_&lt;SETTING_NAME&gt;</code> to a setting with name <code>SETTING_NAME</code>, overriding a setting with the same name from <code>local_settings.py</code> or the default settings.</p> <p>So an environment variable <code>SM_SLACK_APP_TOKEN</code> will result in a setting <code>SLACK_APP_TOKEN</code>.</p> <p>Setting names are case insensitive.</p>"},{"location":"plugins/settings/#example-of-using-settings","title":"Example of using settings","text":"<p>When the <code>local_settings.py</code> looks like this:</p> <pre><code>SLACK_APP_TOKEN = \"xapp-my-app-token\"\nSLACK_BOT_TOKEN = \"xoxb-my-bot-token\"\nGREETING_PLUGIN_MY_GREETING = \"Bonjour\"\n</code></pre> <p>This can be used in a plugin, like this:</p> <pre><code>@respond_to(r\"Hello!\")\nasync def greeting(self, msg):\n    await msg.reply(f\"{self.settings['GREETING_PLUGIN_MY_GREETING']}, {msg.at_sender}!\")\n</code></pre> <p>The response to a message @superbot Hello! from @john, in this case would be: Bonjour, @john!</p>"},{"location":"plugins/settings/#required-settings","title":"Required settings","text":"<p>If your plugin requires one or more settings to be defined in order to work, you can mark them as required with the <code>@required_settings</code> decorator. This decorator takes a string or a list of strings as argument which can be one or more settings that are required by your plugin. Upon startup, Slack Machine will check if any of the settings that are marked as required by a plugin, have not been defined by the user. If it finds one or more missing settings, it will not load that particular plugin, and notify the user which settings are missing.</p> <p>The <code>@required_settings</code> decorator can be applied to a plugin class and/or its methods. Note that if any of the required settings are missing, the plugin will not load as a whole, so none of the methods will be registered.</p> <p>Example:</p> <pre><code>@required_settings([\"TODO_SERVICE_USERNAME\", \"TODO_SERVICE_PASSWORD\"])\nclass TodoPlugin(MachineBasePlugin):\n    ...\n</code></pre>"},{"location":"plugins/slash-commands/","title":"Slash Commands","text":"<p>Next to triggering Slack Machine by listening to messages that match a specific regular expression, you can also use Slash Commands in Slack Machine.</p>"},{"location":"plugins/slash-commands/#creating-a-slash-command","title":"Creating a Slash Command","text":"<p>To configure a Slash Command for your Slack App, you can follow the instructions in the official Slack documentation. As you will have likely followed the guide to using Slack Machine, you propbably have already defined a Slack App. This is what you need to do next:</p> <ol> <li>Go to your app's management dashboard</li> <li>Click your Slack App</li> <li>Go to Slash Commands in the navigation menu</li> <li>Click the Create New Command button and follow the instructions</li> </ol>"},{"location":"plugins/slash-commands/#using-the-app-manifest","title":"Using the App manifest","text":"<p>If you used the example App manifest when creating your Slack App, you can also adjust that to include the Slash Commands you want to define. You can add it under <code>features</code> as follows:</p> <pre><code>features:\nbot_user:\ndisplay_name: My Bot\nalways_online: false\nslash_commands:\n- command: /hello\ndescription: Say hello\nusage_hint: \"[whatever else you want to say]\"\nshould_escape: false\n</code></pre>"},{"location":"plugins/slash-commands/#defining-your-slash-command-in-code","title":"Defining your Slash Command in code","text":"<p>The next step is to use the <code>command</code> decorator on the function that should be triggered when the user uses the Slash Command you defined. The decorator takes only 1 parameter: the slash command that should trigger the decorated function. It should be the same as the Slash Command you just defined in the App dashboard.</p> <p>This is what a decorated command handler typically looks like:</p> <pre><code>@command(\"/hello\")\nasync def hello(self, command):\n    print(f\"I just received the following command: {command.command} with text {command.text}\")\n    await command.say(\"I like greetings!\")\n</code></pre>"},{"location":"plugins/slash-commands/#parameters-of-your-command-handler","title":"Parameters of your command handler","text":"<p>Your command handler will be called with a <code>Command</code> object that contains useful information about the slash command invocation. The most important property is probably <code>text</code>, which contains any additional text that was passed when the slash command was used.</p> <p>You can optionally pass the <code>logger</code> argument to get a logger that was enriched by Slack Machine</p>"},{"location":"plugins/slash-commands/#responding-to-a-command","title":"Responding to a command","text":"<p>Responding to Slash Commands is a timely business. As explained in the official documentation, the receipt of the slash command payload has to be acknowledged. This has to happen within 3 seconds, or Slack will return an error to the user. To make your life easy, Slack Machine will handle all of this.</p> <p>If you want to send a message to the user after a slash command was invoked, you can do so by calling the <code>say()</code> method on the command object your handler received from Slack Machine. This works just like any other way Slack provides for sending messages. You can include just text, but also rich content using Block Kit</p> <p>Info</p> <p>The <code>response_url</code> property is used by the <code>say()</code> method to send messages to a channel after receiving a command. It does so by invoking a Webhook using this <code>response_url</code> This is different from how <code>message.say()</code> works - which uses the Slack Web API.</p> <p>The reason for this is to keep consistency with how Slack recommends interacting with a user. For commands, using the <code>response_url</code> is the recommended way</p> <p>If you read the aforementioned documentation on responding to commands carefully, you'll notice that as part of acknowleding the receipt of a command payload, you can return a response to the user (which has to happen in 3 seconds). This is different from the <code>command.say()</code> method, which does not have any timing requirements. Slack Machine supports returning an immediate response by turning your command handler into a generator and returning an immediate response through <code>yield</code>:</p> <pre><code>@command(\"/hello-again\")\nasync def hello_again(self, command):\n    print(f\"I just received the following command: {command.command} with text {command.text}\")\n    # this is sent as part of the initial payload acknowledgement\n    yield \"This will be returned immediately to the user\"\n    # this is less time-sensitive\n    await command.say(\"This will be sent after the initial acknowledgement\")\n</code></pre>"},{"location":"plugins/slash-commands/#other-types-of-responses","title":"Other types of responses","text":"<p>The <code>Command</code> object that your handler receives, contains an extra piece of information you can use to trigger more varied reponses: the <code>trigger_id</code> The <code>trigger_id</code> can used specifically to trigger modal responses. For now, creating a modal is something you have to take care of yourself. More information on this can be found here.</p> <p>In future releases, Slack Machine will make working with modals much easier by allowing modals to be opened directly through the provided command object, and responding to interactions happening in modals through new decorators.</p>"},{"location":"plugins/storage/","title":"Storage","text":"<p>Slack Machine provides persistent storage that can easily be accessed from plugins through <code>self.storage</code>. This field contains an instance of <code>PluginStorage</code>, which lets you store, retrieve and remove values by key, check for the existence of a key and get information about the current size of the underlying storage.</p> <p>The <code>PluginStorage</code> class interfaces with whatever storage backend Slack Machine is configured with. You can read more about the available storage backends in the user guide.</p> <p>Example:</p> <pre><code>@respond_to(r\"store (?P&lt;text&gt;.*) under (?P&lt;key&gt;\\w+)\")\nasync def store(self, msg, text, key):\n    await self.storage.set(key, text)\n    await msg.say(f\"'{text}' stored under {key}!\")\n\n@respond_to(r\"retrieve (?P&lt;key&gt;\\w+)\")\nasync def retrieve(self, msg, key):\n    data = await self.storage.get(key)\n    if data:\n        await msg.say(f\"'{data}' retrieved from &lt;{key}&gt;!\")\n    else:\n        await msg.say(\"Key not found!\")\n\n@respond_to(r\"delete (?P&lt;key&gt;\\w+)\")\nasync def delete(self, msg, key):\n    await self.storage.delete(key)\n    await msg.say(f\"data in &lt;{key}&gt; deleted!\")\n\n@respond_to(r\"does (?P&lt;key&gt;\\w+) exist?\")\nasync def exists(self, msg, key):\n    if await self.storage.has(key):\n        await msg.say(f\"&lt;{key}&gt; exists.\")\n    else:\n        await msg.say(f\"&lt;{key}&gt; does not exist!\")\n\n@respond_to(r\"size\")\nasync def size(self, msg):\n    human_size = await self.storage.get_storage_size_human()\n    await msg.say(\"storage size: {human_size}\")\n</code></pre>"},{"location":"plugins/storage/#shared-vs-non-shared","title":"Shared vs non-shared","text":"<p>By default, when you store, retrieve and remove data by key, Slack Machine will automatically namespace the keys you use with the fully qualified classname of the plugin the storage is used from. This is done to prevent plugins from changing or even deleting each others data. So when you do this:</p> <pre><code># resides in module my.plugin.package\nclass MyPlugin:\n    async def some_function():\n        await self.storage.set(\"my-key\", \"my-data\")\n</code></pre> <p>Slack Machine will send the key <code>my.plugin.package.MyPlugin:my-key</code> to the storage backend.</p> <p>You can override this behaviour by setting the <code>shared</code> parameter to <code>True</code> when calling a storage related function that requires a key as parameter. This keep the key global (ie. non-namespaced). This is useful when you want to share data between plugins. Use this feature with care though, as you can destroy data that belongs to other plugins!</p>"},{"location":"plugins/storage/#implementing-your-own-storage-backend","title":"Implementing your own storage backend","text":"<p>You can implement your own storage backend by subclassing [<code>MachineBaseStorage</code>][machine.storage.backends.base. MachineBaseStorage]. You only have to implement a couple of methods, and you don't have to take care of namespacing of keys, as Slack Machine will do that for you.</p>"},{"location":"user/install/","title":"Installation","text":"<p>This part of the documentation helps you install Slack Machine with the least amount of friction, or the most amount of flexibility.</p>"},{"location":"user/install/#installing-the-easy-way-with-pip","title":"Installing the easy way with pip","text":"<p>Slack Machine is published to the Python package index so you can easily install Slack Machine using pip:</p> <pre><code>pip install slack-machine\n</code></pre> <p>or add it to your Poetry project:</p> <pre><code>poetry add slack-machine\n</code></pre> <p>It is strongly recommended that you install <code>slack-machine</code> inside a virtual environment!</p>"},{"location":"user/install/#installing-from-source","title":"Installing from source","text":"<p>If you are adventurous, want to modify the core of your Slack Machine instance and want maximum flexibility, you can also install from source. This way, you can enjoy the latest and greatest!</p> <p>You can either clone the public repository:</p> <pre><code>git clone git://github.com/DonDebonair/slack-machine.git\n</code></pre> <p>Or, download the tarball:</p> <pre><code>curl -OL https://github.com/DonDebonair/slack-machine/tarball/main\n</code></pre> <p>Optionally, zipball is also available (for Windows users).</p> <p>Once you have a copy of the source, you can embed it in your own Python package, or install it into your virtualenv easily:</p> <pre><code>cd slack-machine\npip install .\n</code></pre>"},{"location":"user/intro/","title":"Introduction","text":""},{"location":"user/intro/#philosophy","title":"Philosophy","text":"<p>Slack Machine is a simple, yet powerful and extendable bot framework &amp; platform for Slack.</p> <p>Slack Machine should be:</p> <ul> <li>Full-featured</li> <li>Easy to extend</li> <li>Easy to contribute to (the core)</li> <li>Fun to use</li> <li>Fun to extend</li> </ul> <p>My dream would be, that a community springs up around Slack Machine, that produces a myriad of useful plugins that are easy to install and use.</p>"},{"location":"user/intro/#non-goals","title":"Non-goals","text":"<p>These are non-goals for me at the moment, but that might change in the future:</p> <ul> <li>Support for other backends than Slack</li> <li>Built-in AI. At least not in the core, although whatever intelligence developers put into their plugins, is cool of   course</li> </ul>"},{"location":"user/intro/#why-slack-machine-was-built","title":"Why Slack Machine was built","text":"<p>I love Slack, and I use it on a daily basis, both at work and in my private life. Due to the powerful APIs that Slack exposes, it's not only great for chatting, but also for automation. We developers love automation, so I wanted to add some of that to the Slack workspaces I'm a member of. Obviously, there have already been many attempts to leverage this extensibility of Slack, considering the many apps/bots/bot frameworks/chatops frameworks out there.</p> <p>Why build another one?!</p> <p>All of the options that I could find, were inadequate for some reason. I've used Hubot a lot in the past, but Coffeescript (or Javascript for that matter), just doesn't click with me. I personally feel that Python is a great language to tackle this sort of problem, so I started looking for Slack bots written in Python. At the time I created Slack Machine, these were the options I could find:</p> <ul> <li>python-rtmbot: Created by the Slack team, this bot is very barebones and   exposes a very low-level plugin API. This makes it hard/tedious to write plugins for it. It is not mainainted anymore</li> <li>slackbot: Has a more high-level plugin API, which is built on the right   ideas in terms of developer friendlyness. But it was lacking some features that I want in a bot (among other   things: scheduling, persistent storage and a help-feature), and I found that the plugin architecture didn't allow for   proper plugin organisation. This made me decide not to contribute, and instead start my own project.</li> <li>Will: This was originally not a bot for Slack, but for Hipchat, but it has support   for Slack (and other backends) since a couple of years. I'm including it. Will came closests to what I want, both   in terms of feature set and plugin API. At the time I created Slack Machine, it only supported HipChat and I   personally found the code quite hard to read. I also feel that a framework supporting many different chat   platforms is bound to serve the lowest common denominator. This will lead to suboptimal quality.</li> </ul> <p>So, in the end I decided that writing a full-featured, easy-to-extend Slack bot, written in Python, would be cool new project to take up.</p> <p>Note</p> <p>The above was written 4 years ago and a lot has changed since then. The Slack team has created Bolt, a bot framework that is quite similar to Slack Machine. There are still differences in the way code is organized and I feel that Slack Machine is better suited to build complex Slack bots with in which code is organized in multiple plugins. This is currently not supported by Bolt</p> <p>I plan to keep maintaining Slack Machine and bringing it up to date with current best practices, so that the features and developer experience are on-par with or better than Bolt</p>"},{"location":"user/intro/#acknowledgements","title":"Acknowledgements","text":"<p>Slack Machine owes a great deal of debt to the aforementioned packages. Parts of the API of Slack Machine were inspired by those packages, and I was at a great advantage while building Slack Machine because I was able to look at existing code to get an idea on how to approach certain problems. While obviously I'd like to think I have improved upon my inspirations, Slack Machine couldn't have existed without them.</p>"},{"location":"user/intro/#slack-machine-license","title":"Slack Machine License","text":"<p>MIT License</p> <p>Copyright (c) 2018 Daan Debie</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"user/usage/","title":"Using Slack Machine","text":"<p>Once you have installed Slack Machine, configuring and starting your bot is easy:</p> <ol> <li>Create a directory for your Slack Machine bot: <code>mkdir my-slack-bot &amp;&amp; cd my-slack-bot</code></li> <li>Add a <code>local_settings.py</code> file to your bot directory: <code>touch local_settings.py</code></li> <li>Create a new app in Slack: https://api.slack.com/apps</li> <li>Choose to create an app from an App manifest</li> <li> <p>Copy/paste the following manifest:</p> manifest.yaml<pre><code>display_information:\n  name: Slack Machine\nfeatures:\n  bot_user:\n    display_name: Slack Machine\n    always_online: false\noauth_config:\n  scopes:\n    bot:\n      - app_mentions:read\n      - channels:history\n      - channels:join\n      - channels:read\n      - chat:write\n      - chat:write.public\n      - emoji:read\n      - groups:history\n      - groups:read\n      - groups:write\n      - im:history\n      - im:read\n      - im:write\n      - mpim:history\n      - mpim:read\n      - mpim:write\n      - pins:read\n      - pins:write\n      - reactions:read\n      - reactions:write\n      - users:read\n      - users:read.email\n      - channels:manage\n      - chat:write.customize\n      - dnd:read\n      - files:read\n      - files:write\n      - links:read\n      - links:write\n      - metadata.message:read\n      - usergroups:read\n      - usergroups:write\n      - users.profile:read\n      - users:write\nsettings:\n  event_subscriptions:\n    bot_events:\n      - app_home_opened\n      - app_mention\n      - channel_archive\n      - channel_created\n      - channel_deleted\n      - channel_id_changed\n      - channel_left\n      - channel_rename\n      - channel_unarchive\n      - group_archive\n      - group_deleted\n      - group_left\n      - group_rename\n      - group_unarchive\n      - member_joined_channel\n      - member_left_channel\n      - message.channels\n      - message.groups\n      - message.im\n      - message.mpim\n      - reaction_added\n      - reaction_removed\n      - team_join\n      - user_change\n      - user_profile_changed\n      - user_status_changed\n  interactivity:\n    is_enabled: true\n  org_deploy_enabled: false\n  socket_mode_enabled: true\n  token_rotation_enabled: false\n</code></pre> </li> <li> <p>Add the Slack App and Bot tokens to your <code>local_settings.py</code> like this:</p> local_settings.py<pre><code>SLACK_APP_TOKEN = \"xapp-my-app-token\"\nSLACK_BOT_TOKEN = \"xoxb-my-bot-token\"\n</code></pre> </li> <li> <p>Start the bot with <code>slack-machine</code></p> </li> <li>...</li> <li>Profit!</li> </ol>"},{"location":"user/usage/#configuring-slack-machine","title":"Configuring Slack Machine","text":"<p>All the configuration for your bot lives in the <code>local_settings.py</code> in the root of your bot directory. The core of Slack Machine, and the most of the built-in plugins, only need a <code>SLACK_APP_TOKEN</code> and <code>SLACK_BOT_TOKEN</code> to function.</p> <p>You can override the log level by setting <code>LOGLEVEL</code>. By default this is set to <code>\"ERROR\"</code>.</p> <p>Warning</p> <p>If you set the <code>LOGLEVEL</code> to <code>DEBUG</code>, all events your Slack App is subscribed to, will be logged.</p> <p>If you want to use Slack Machine behind a proxy, you can set <code>HTTP_PROXY</code>.</p>"},{"location":"user/usage/#using-environment-variables-for-configuration","title":"Using environment variables for configuration","text":"<p>For some configuration, it can be a security consideration not to store them in your source code (i.e. <code>local_settings.py</code>) Slack Machine allows you to provide any setting - both built-in and for plugins - as environment variables. This is done by prefixing the setting name with <code>SM_</code>. Example: <code>SM_SLACK_APP_TOKEN</code> and <code>SM_SLACK_BOT_TOKEN</code> as environment variable can be used to set the <code>SLACK_APP_TOKEN</code> and <code>SLACK_BOT_TOKEN</code> settings instead of having to put it in the <code>local_settings.py</code>.</p> <p>This way you can follow the 12 Factor app best practices to configure your bot!</p>"},{"location":"user/usage/#setting-aliases","title":"Setting aliases","text":"<p>The <code>ALIASES</code> configuration setting allows the bot to respond to a trigger symbol instead of a direct @botname.</p> <p>Example:</p> <p>If <code>ALIASES='!,%'</code> was set in <code>local_settings.py</code> then the bot would respond to the following phrases:</p> <pre><code>@botname release the hounds\n!release the hounds\n%release the hounds\n</code></pre>"},{"location":"user/usage/#enabling-plugins","title":"Enabling plugins","text":"<p>Slack Machine comes with a few simple built-in plugins:</p> <ul> <li>HelloPlugin: responds in kind when users greet the bot with   \"hello\" or \"hi\" (only when the bot is mentioned)</li> <li>PingPongPlugin: responds to \"ping\" with \"pong\" and vice   versa (listens regardless of mention)</li> <li>EchoPlugin: replies to any message the bot hears, with exactly   the same message. The bot will reply to the same channel the   original message was heard in</li> <li>HelpPlugin: responds to \"help\" with a list of all available commands and how they work. You can use \"robot   help\" to learn the regexes that are used to match commands.</li> <li>MemePlugin: lets the user generate memes based on templates and captions Uses Memegen</li> <li>ImageSearchPlugin: lets users search images and gifs using Google Custom Search (requires setting up a   Programmable Search Engine in Google and adding the   search engine id as <code>GOOGLE_CSE_ID</code> and a Google API key as <code>GOOGLE_API_KEY</code>)</li> <li>RBACPlugin: lets admins assign, revoke and list user roles. Is used when you want to   protect commands</li> </ul> <p>By default, HelloPlugin and PingPongPlugin are enabled.</p> <p>You can specify which plugins Slack Machine should load, by setting the <code>PLUGINS</code> variable in <code>local_settings.py</code> to a list of fully qualified classes or modules that contain plugins. You can either point to a plugin class directly, or to a module containing one or more plugins.</p> <p>For example, to enable most of the built-in Slack Machine plugins, your <code>local_settings.py</code> would look like this:</p> <pre><code>SLACK_APP_TOKEN = \"xapp-my-app-token\"\nSLACK_BOT_TOKEN = \"xoxb-my-bot-token\"\nPLUGINS = [\n    \"machine.plugins.builtin.general.PingPongPlugin\",\n    \"machine.plugins.builtin.general.HelloPlugin\",\n    \"machine.plugins.builtin.debug.EchoPlugin\",\n    \"machine.plugins.builtin.fun.memes.MemePlugin\",\n    \"machine.plugins.builtin.help.HelpPlugin\",\n]\n</code></pre> <p>Or is you want import them by the modules they're in:</p> <pre><code>SLACK_APP_TOKEN = \"xapp-my-app-token\"\nSLACK_BOT_TOKEN = \"xoxb-my-bot-token\"\nPLUGINS = [\n    \"machine.plugins.builtin.general\",\n    \"machine.plugins.builtin.debug\",\n    \"machine.plugins.builtin.help\",\n    \"machine.plugins.builtin.fun.memes\",\n]\n</code></pre> <p>Slack Machine can load any plugin that is on the Python path. This means you can load any plugin that is installed in the same virtual environment you installed Slack Machine in. And as a convenience, Slack Machine will also add the directory you start Slack Machine from, to your Python path.</p>"},{"location":"user/usage/#choosing-storage","title":"Choosing storage","text":"<p>Slack Machine provides persistent storage, which can be used by plugins to store data of any kind. Slack Machine supports different backends for storage, so you can choose one that best fits your needs and existing infrastructure. You can configure which backend to use, by setting the <code>STORAGE_BACKEND</code> variable in <code>local_settings.py</code> to the fully qualified class of the chosen storage backend.</p> <p>Out of the box, Slack Machine provides 4 options for storage backend:</p>"},{"location":"user/usage/#in-memory-default","title":"in-memory (default)","text":"<p>This backend will store all data in-memory, which is great for testing because it doesn't have any external dependencies. Does not persist data between restarts</p> <p>Class: <code>machine.storage.backends.memory.MemoryStorage</code></p>"},{"location":"user/usage/#redis","title":"Redis","text":"<p>Install with: <code>pip install 'slack-machine[redis]'</code></p> <p>This backend stores data in Redis. Redis is a very fast key-value store that is super easy to install and operate. This backend is recommended, because it will persist data between restarts. The Redis backend requires you to provide a URL to your Redis instance by setting the <code>REDIS_URL</code> variable in <code>local_settings.py</code>. The URL should have the following format:</p> <pre><code>`redis://&lt;host&gt;:&lt;port&gt;[/&lt;db&gt;]`\n</code></pre> <p>Where <code>db</code> is optional and sets the database number (0 by default)</p> <p>Optional parameters:</p> <ul> <li><code>REDIS_MAX_CONNECTIONS</code>: maximum number of connections Slack   Machine can make to your Redis instance</li> <li><code>REDIS_KEY_PREFIX</code>: the prefix Slack Machine uses for keys (<code>SM</code>   by default, so \"key1\" gets stored under <code>SM:key1</code>)</li> </ul> <p>Class: <code>machine.storage.backends.redis.RedisStorage</code></p>"},{"location":"user/usage/#dynamodb","title":"DynamoDB","text":"<p>Install with: <code>pip install 'slack-machine[dynamodb]'</code></p> <p>This backend stores data in DynamoDB. DynamoDB is a managed NoSQL datastore on AWS that, among other things, allows for easy persistance of objects by key. The DynamoDB backend requires either a set of valid AWS account credentials, or a locally running DynamoDB test bed, such as the one included in localstack. This backend requires the environment variables or path-based AWS credentials that are normally used to access AWS services. The following are optional parameters that can be set in your <code>local_settings.py</code> or <code>SM_</code> environment variable slack-machine settings:</p> <p>Optional parameters:</p> <ul> <li><code>DYNAMODB_ENDPOINT_URL</code>: specifies an optional alternate endpoint, for local bot testing</li> <li><code>DYNAMODB_KEY_PREFIX</code>: an optional prefix to use within the key lookup. Defaults to <code>SM:</code></li> <li><code>DYNAMODB_TABLE_NAME</code>: specifies the table to use in DynamoDB. Defaults to <code>slack-machine-state</code></li> <li><code>DYNAMODB_CREATE_TABLE</code>: optionally -create- the table to be used in DynamoDB. Defaults to <code>False</code></li> <li><code>DYNAMODB_CLIENT</code>: if custom configuration is needed for the DynamoDB client, an optional   <code>aioboto3</code> resource can be specified here</li> </ul> <p>Class: <code>machine.storage.backends.dynamodb.DynamoDBStorage</code></p>"},{"location":"user/usage/#sqlite","title":"SQLite","text":"<p>Install with: <code>pip install 'slack-machine[sqlite]'</code></p> <p>This backend stores data in SQLite. SQLite is a C library that provides a lightweight disk-based database that doesn\u2019t require a separate server process and allows accessing the database using a non-standard variant of the SQL query language.</p> <p>The SQLite backend requires you to provide a filename that will be used to store the data by setting the <code>SQLITE_PATH</code> variable in <code>local_settings.py</code>. The filename can be relative or absolute:</p> <pre><code>`SQLITE_PATH: /path/to/slack-machine.db`\n</code></pre> <p>Class: <code>machine.storage.backends.sqlite.SQLiteStorage</code></p> <p>So if, for example, you want to configure Slack Machine to use Redis as a storage backend, with your Redis instance running on localhost on the default port, you would add this to your <code>local_settings.py</code>:</p> <pre><code>STORAGE_BACKEND = 'machine.storage.backends.redis.RedisStorage'\nREDIS_URL = redis://localhost:6379'\n</code></pre> <p>That's all there is to it!</p>"}]}